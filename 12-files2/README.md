
# Файлы и каталоги

## Функции stat, fstat и lstat

```c
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat restrict buf);
```
Функция stat возвращает структуру с информацией о файле, указанном в аргументе pathname. Функция fstat возвращает информацию об открытом файле, который определяется дескриптором filedes. 
Функция lstat похожа на функцию stat, но когда ей передается имя символической ссылки, она возвращает сведения о самой символической ссылке, а не о файле, на который она ссылается.
Второй аргумент, buf, является указателем на структуру, которую функция будет заполнять информацией. Определение структуры может отличаться для разных реализаций, но основная ее часть выглядит следующим образом:

```c
struct stat {
    mode_t st_mode; /* тип файла и режим (права доступа) */
    ino_t st_ino; /* номер индексного узла */
    dev_t st_dev; /* номер устройства (файловой системы) */
    dev_t st_rdev; /* номер устройства для специальных файлов */
    nlink_t st_nlink; /* количество ссылок */
    uid_t st_uid; /* идентификатор пользователя владельца */
    gid_t st_gid; /* идентификатор группы владельца */
    off_t st_size; /* размер в байтах, для обычных файлов */
    time_t st_atime; /* время последнего обращения к файлу */
    time_t st_mtime; /* время последнего изменения файла */
    time_t st_ctime; /* время последнего изменения флагов состояния файла */
    blksize_t st_blksize; /* оптимальный размер блока ввода вывода */
    blkcnt_t st_blocks; /* количество занятых дисковых блоков */
};
```
## Типы файлов

1. Обычный файл – наиболее распространенный тип файлов, который хранит данные в том или ином виде. Ядро UNIX не делает различий между
текстовыми и двоичными файлами. Любая интерпретация содержимого файла полностью возлагается на прикладную программу, обрабатываю 
щую файл.
2. Файл каталога. Файлы этого типа содержат имена других файлов и ссылки на информацию о них. Любой процесс, обладающий правом на чтение
каталога, может проверить его содержимое, но только ядро обладает правом на запись в файл каталога. Чтобы внести изменения в каталог, про 
цессы должны пользоваться функциями, обсуждаемыми в данной главе.
3. Специальный файл блочного устройства. Этот тип файлов обеспечивает буферизованный ввод вывод для таких устройств, как дисковые устрой 
ства с фиксированным размером блока.
4. Специальный файл символьного устройства. Этот тип файлов обеспечивает небуферизованный ввод вывод для устройств с переменным размером
блока. Все устройства в системе являются либо специальными файлами блочных устройств, либо специальными файлами символьных устройств.
5. FIFO, или именованный канал. Этот тип файлов используется для организации обмена информацией между процессами. 
6. Сокет. Этот тип файлов используется для организации обмена информацией между процессами через сетевые соединения. Сокеты можно применять и для обмена информацией между процессами на одной и той же ма 
шине. 
7. Символическая ссылка. Файлы этого типа представляют собой ссылки на другие файлы.

Тип файла хранится в поле st_modeструктуры stat. Определить тип файла можно с помощью макроопределений, приведенных ниже 
(Макросы для определения типа файла из  ```<sys/stat.h>```)

 * S_ISREG() Обычный файл
 * S_ISDIR() Каталог
 * S_ISCHR() Специальный файл символьного устройства
 * S_ISBLK() Специальный файл блочного устройства
 * S_ISFIFO() Канал (именованный или неименованный)
 * S_ISLNK() Символическая ссылка
 * S_ISSOCK Сокет

## Системный вызов access

```c
#include <unistd.h>

int access(const char *pathname, int mode);
```

Проверяет, какие операции с файлом по данному пути процесс может выполнить. Симлинки разыменовываются. Что можно проверить (флаги в mode, можно комбинировать через побитовое или):

* F_OK - просто факт существования
* R_OK - файл можно читать
* W_OK - в файл можно писать
* X_OK - файл можно исполнить

В случае успеха (всё, что спрашивалось, можно) вызов возвращает 0. В противном случае (в том числе, в случае ошибки) вызов возвращает -1 и выставляет errno в соответствии с причиной отказа.

## Работа с каталогами.

Создание каталогов производится с помощью функции mkdir, а удаление – с помощью функции rmdir.

```c
#include <sys/stat.h>

int mkdir(const char *pathname, mode_t mode); /* Возвращает 0 в случае успеха, –1 в случае ошибки*/
```

```c
#include <unistd.h>

int rmdir(const char *pathname); /* Возвращает 0 в случае успеха, –1 в случае ошибки */
```

```c
#include <dirent.h>

DIR *opendir(const char *pathname); //Возвращает указатель в случае успеха или NULL в случае ошибки.
struct dirent *readdir(DIR *dp); // Возвращает указатель в случае успеха, 
                                 // NULL в случае достижения конца каталога или ошибки.
void rewinddir(DIR *dp); // Обнуляет текущую позицию в директории. Вызов всегда успешен.
int closedir(DIR *dp); // Парный вызов для opendir. Возвращает 0 в случае успеха или –1 в случае ошибки.
long telldir(DIR *dp); // Возвращает значение текущей позиции в каталоге, ассоциированном с dp, 
                       // или -1 в случае ошибки.
void seekdir(DIR *dp, long loc); // Устанавливает текущую позицию в директории. Вызов всегда успешен.
```

Функции telldir и seekdir не являются частью стандарта POSIX.1. Это расширения XSI стандарта Single UNIX Specification – таким образом, предполагается, что они должны быть реализованы во всех версиях UNIX, следующих этой спецификации.

Структура dirent определена в файле <dirent.h> и зависит от конкретной реализации. Однако в любой версии UNIX эта структура содержит как минимум следующие два поля:

```c
struct dirent {
    ino_t d_ino; /* номер индексного узла */
    char d_name[NAME_MAX + 1]; /* строка имени файла, завершающаяся нулевым символом */
}
```

Пример: Рекурсивный обход дерева каталогов с подсчетом количества файлов по типам

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <dirent.h>
#include <limits.h>

/* тип функции, которая будет вызываться для каждого встреченного файла */
typedef int Myfunc(const char *, const struct stat *, int);

static Myfunc myfunc;
static int myftw(char *, Myfunc *);
static int dopath(Myfunc *);

static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;

int main(int argc, char *argv[]) {
    int ret;
    if (argc != 2) {
        fprintf(stderr, "Использование: ftw <начальный_каталог>\n");
        exit(1);
    }
    ret = myftw(argv[1], myfunc); /* выполняет всю работу */
    ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;
    if (ntot == 0)
        ntot = 1;/* во избежание деления на 0; вывести 0 для всех счетчиков */
    printf("обычные файлы = %7ld, %5.2f %%\n", nreg,nreg*100.0/ntot);
    printf("каталоги = %7ld, %5.2f %%\n", ndir, ndir*100.0/ntot);
    printf("специальные файлы блочных устройств = %7ld, %5.2f %%\n", nblk,nblk*100.0/ntot);
    printf("специальные файлы символьных устройств = %7ld, %5.2f %%\n", nchr,nchr*100.0/ntot);
    printf("FIFO = %7ld, %5.2f %%\n", nfifo,nfifo*100.0/ntot);
    printf("символические ссылки = %7ld, %5.2f %%\n", nslink, nslink*100.0/ntot);
    printf("сокеты = %7ld, %5.2f %%\n", nsock,nsock*100.0/ntot);
    exit(ret);
}

/*
* Обойти дерево каталогов, начиная с каталога "pathname".
* Пользовательская функция func() вызывается для каждого встреченного файла.
*/

#define FTW_F 1 /* файл, не являющийся каталогом */
#define FTW_D 2 /* каталог */
#define FTW_DNR 3 /* каталог, который не доступен для чтения */
#define FTW_NS 4 /* файл, информацию о котором невозможно получить с помощью stat */

static char *fullpath; /* полный путь к каждому из файлов */

/* возвращаем то, что вернула функция func() */
static int myftw(char *pathname, Myfunc *func) {
    int len = PATH_MAX + 1;
    fullpath = malloc(len); /* выделить память для PATH_MAX+1 байт */
    if (fullpath == NULL) {
        fprintf(stderr, "не получается выделить память: %s\n", strerror(errno));
        fflush(NULL);
        abort();
    }
    strncpy(fullpath, pathname, len); /* защита от */
    fullpath[len-1] = 0; /* переполнения буфера */
    return(dopath(func));
}

/*
* Обход дерева каталогов, начиная с "fullpath". Если "fullpath" не является 
* каталогом, для него вызывается lstat(), func() и затем выполняется возврат. 
* Для каталогов производится рекурсивный вызов функции.
*/
/* возвращаем то, что вернула функция func() */
static int dopath(Myfunc* func) {
    struct stat statbuf;
    struct dirent *dirp;
    DIR *dp;
    int ret;
    char *ptr;
    
    if (lstat(fullpath, &statbuf) < 0) /* ошибка вызова функции stat */
        return func(fullpath, &statbuf, FTW_NS);
    if (S_ISDIR(statbuf.st_mode) == 0) /* не каталог */
        return func(fullpath, &statbuf, FTW_F);

    /*
    * Это каталог. Сначала вызовем функцию func(),
    * а затем обработаем все файлы в этом каталоге.
    */

    if ((ret = func(fullpath, &statbuf, FTW_D)) != 0)
        return ret;

    ptr = fullpath + strlen(fullpath); /* установить указатель */

    /* в конец fullpath */
    *ptr++ = ’/’;
    *ptr = 0;
    if ((dp = opendir(fullpath)) == NULL) /* каталог недоступен */
        return func(fullpath, &statbuf, FTW_DNR);

    while ((dirp = readdir(dp)) != NULL) {
        if (strcmp(dirp->d_name, ".") == 0 || strcmp(dirp->d_name, "..") == 0)
            continue; /* пропустить каталоги "." и ".." */
        strcpy(ptr, dirp->d_name); /* добавить имя после слэша */

        if ((ret = dopath(func)) != 0) /* рекурсия */
            break; /* выход по ошибке */
    }

    ptr[-1] = 0; /* стереть часть строки от слэша и до конца */

    if (closedir(dp) < 0)
        fprintf(stderr,"невозможно закрыть каталог %s: %s\n", fullpath, strerror(errno));

    return ret;
}

static int myfunc(const char *pathname, const struct stat *statptr, int type) {
    switch (type) {
    case FTW_F:
        switch (statptr->st_mode & S_IFMT) {
        case S_IFREG: nreg++; break;
        case S_IFBLK: nblk++; break;
        case S_IFCHR: nchr++; break;
        case S_IFIFO: nfifo++; break;
        case S_IFLNK: nslink++; break;
        case S_IFSOCK: nsock++; break;
        case S_IFDIR:
            fprintf(stderr, "признак S_IFDIR для %s: %s\n", pathname, strerror(errno));
            fflush(NULL);
            abort();
            /* каталоги должны иметь тип = FTW_D */
    }
    break;
    case FTW_D:
        ndir++;
        break;
    case FTW_DNR:
        fprintf(stderr,"закрыт доступ к каталогу %s: %s\n", pathname, strerror(errno));
        break;
    case FTW_NS:
        fprintf(stderr,"ошибка вызова функции stat для %s: %s\n", pathname, strerror(errno));
        break;
    default:
        fprintf(stderr, "неизвестный тип %d для файла %s: %s\n", type, pathname, strerror(errno));
        fflush(NULL);
        abort();
    }
    return 0;
}
```

## Функции chdir, fchdir и getcwd

Для каждого процесса определен текущий рабочий каталог. Относительно этого каталога вычисляются все относительные пути (то есть пути, которые не начинаются с символа слэша). Когда пользователь входит в систему, текущим рабочим каталогом обычно становится каталог, указанный в шестом поле записи из файла /etc/passwd, – домашний каталог пользователя. Текущий рабочий каталог – это атрибут процесса, домашний каталог – атрибут пользователя. Процесс может изменить текущий рабочий каталог с помощью функции chdirили fchdir.

```c
#include <unistd.h>

int chdir(const char *pathname);
int fchdir(int filedes); 
/* Возвращают 0 в случае успеха, –1 в случае ошибки */
```

Пример использования функции chdir

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    if (chdir("/tmp") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }
    printf("каталог /tmp стал текущим рабочим каталогом\n");
    exit(0);
}
```

Поскольку ядро хранит сведения о текущем рабочем каталоге, должен быть способ получить его текущее значение. К сожалению, ядро хранит не полный путь к каталогу, а некоторую иную информацию, такую как указатель
на виртуальный узел (v-node) каталога. Чтобы определить абсолютный путь к текущему рабочему каталогу, нужна функция, которая будет перемещаться вверх по дереву каталогов, начиная с текущего («точка») и далее через специальные каталоги «точка - точка»,пока не достигнет корневого каталога. В каждом из промежуточных каталогов функция будет читать записи из файла каталога, пока не найдет название, которое соответствует индексному узлу предыдущего каталога. Повторяя эту процедуру до тех пор, пока небудет достигнут корневой каталог, мы в результате получим абсолютный путь к текущему рабочему каталогу. К счастью, такая функция уже существует.

```c
#include <unistd.h>

char *getcwd(char *buf, size_t size);
/* Возвращает указатель на buf в случае успеха, NULL в случае ошибки */
```

Пример использования функции getcwd

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    char *ptr;

    if (chdir("/usr/spool/uucppublic") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }

    if (!(ptr = malloc(PATH_MAX + 1))) {
        fprintf(stderr, "ошибка выделения памяти: %s\n", strerror(errno));
        fflush(NULL);
        abort();
    }

    if (getcwd(ptr, size) == NULL) {
        fprintf(stderr, "ошибка вызова функции getcwd: %s\n", strerror(errno));
        exit(1);
    }

    printf("cwd = %s\n", ptr);
    exit(0);
}
```
