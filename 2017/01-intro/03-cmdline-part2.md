## Цель семинара
Научиться автоматизировать работу в командной строке


## Синтаксис
Командная оболочка `bash` -- это не просто строка для ввода команд, а
полноценный интерпретатор командного shell-языка.

Последовательность команд, которая выполняется в командной строке, может
быть сохранена в текстовом файле для повторного выполнения.

**Пример.** Содержимое файла `myscript.sh`:

```
mkdir ~/new_dir
touch ~/new_dir/new_file.txt
```

Выполнение этой *последовательности команд* осуществляется командой:

```
bash myscript.sh
```

Если в начало файла `myscript.sh` добавить строку (которая с точки зрения
синтаксиса является комментарием) `#!/bin/sh`, и сделать этот файл выполняемым,
то запускается он еще проще:

```
./myscript.sh
```

**Замечание 1.** Суффикс имени `.sh` не обязателен и часто опускается.

**Замечание 2.** Обратите внимание, что первая строка - это `#!/bin/sh`, а
не `#!/bin/bash`. В большинстве дистрибутивов Linux, файл `/bin/sh` является
ссылкой на `/bin/bash`, но в некоторых UNIX-системах (например FreeBSD)
интерпретатор `bash` может быть не установлен по умолчанию, а в качестве
командного интерпретатора использоваться какой-либо другой, sh-совместимый.

### Операторы
 * **`;` (точка с запятой)** -- является разделителем между последовательно
 выполняемыми командами. Этот оператор эквивалентен переносу строки
 * **`&` (амперсанд, `Shift+7`)** -- ставится после команды (и ее аргументов);
 этот оператор означает, что команда будет выполнена в фоновом режиме, а
 интерпретатор продолжает свою работу, не дожидаясь завершения работы команды
 * **`&&` и `||`** -- аналогичны операторам в языке Си. Вызов каждой команды
 возвращает целое число -- код завершения. Логическому значению "истина"
 соотвтетствует код, равный `0`; все остальные коды завершения эквивалентны
 логическому значению "ложь"
 * **`>`, `>>` и `<`** -- операторы перенаправления потока вывода (`>`, `>>`)
 и ввода (`<`) в произвольный файл или из произвольного файла; оператор вывода
 в файл `>` отличается от оператора вывода `>>` тем, что предварительно
 очищает содержимое файла
 * **`|`** -- оператор перенаправления потока вывода из одной команды в
 поток ввода другой команды; ставится между командами.


### Переменные

#### Объявление переменных

Значения переменных объявляются присваиванием:

```
ИМЯ=ЗНАЧЕНИЕ
```

Обратите внимание, что вокруг символа `=` не допускаются пробелы!

Доступ к значениям переменных осуществляется конструкцией `$ИМЯ`.
Переменные обычно именуются заглавными буквами; при использовании в имени
символа подчеркивания необходимо для доступа использовать синтаксис
`${ИМЯ_С_ПОДЧЕРКИВАНИЕМ}` (фигурные скобки вокруг имени).


#### Экспорт значений переменных запускаемым процессам

Переменные доступны только в том сеансе командной строки, в котором они
объявлены (либо до конца выполняемого файла). Для того, чтобы значения
переменных были доступны дочерним запускаемым процессам, их необходимо
*экспортировать* с помощью оператора `export`:

```
export ИМЯ=ЗНАЧЕНИЕ
```

или

```
ИМЯ=ЗНАЧЕНИЕ
export ИМЯ
```

#### Специальные имена переменных

 * `$0` - имя команды текущего процесса
 * `$1`, `$2`, `$3` и т. д. - значения аргументов, переданных shell-скрипту
 * `$*` - список, состоящий из всех аргументов, передеанных shell-скрипту
 * `$#` - количество аргументов
 * `$?` - код возврата предыдущей выполненной команды

### Ключевые слова и конструкции shell-языка

#### Комментарии

Любой текст после `#` (решетка, `Shift+3`) до конца строки является
комментарием, который игнорируется интерпретатором.


#### Текстовый вывод дочернего процесса

Вызов команды, заключенной между символами обратных одинарных кавычек (в
английской раскладке PC-клавиатуры - на одной клавише с буквой "ё"),
возвращает текстовый вывод в виде

#### Проверка условия

**Синтаксис:**

```
if ВЫРАЖЕНИЕ 1
then
    НАБОР КОМАНД 1
elif ВЫРАЖЕНИЕ 2
    НАБОР КОМАНД 2
else
    НАБОР КОМАНД 3
fi
```

Обратите внимание на переносы строк (они могут быть заменены на оператор `;`).

Количество пробелов, в отличии от Python, не имеет никакого значения.

**Пример использования:**

```
#!/bin/sh

if mkdir some_dir/new_subdir
then
    echo "Subdirectory created"
else
    echo "Can't create"
fi
```


#### Выбор варианта

**Синтаксис:**

```
case ПЕРЕМЕННАЯ in
    ВАРИАНТ1|ВАРИАНТ2|ВАРИАНТ3)
       НАБОР КОММАНД 1
       ;;
    ВАРИАНТ4)
       НАБОР КОММАНД 2
       ;;
    *)
       НАБОР КОММАНД 3
       ;;
esac
```

Варианты выбора ограниичиваются закрывающей круглой скобкой; их может быть
несколько, в этом случае они разделяются вертикальной чертой.

Последовательность команд отделяется от следующего выбора двумя символами
точки с запятой `;;`.

**Пример использования:**

```
#!/bin/sh

case $1 in
    --help|-h)
    echo "Usage: $0 --help | --flag1 | --flag2"
    ;;
    --flag1|-f1)
    echo "Flag 1 set"
    ;;
    --flag2|-f2)
    echo "Flag 2 set"
    ;;
    *)
    echo "Unknown argument"
    ;;
esac

```


#### Цикл `while`

**Синтаксис:**

```
while УСЛОВИЕ
do
    НАБОР КОММАНД
done
```

**Пример использования:**

```
#!/bin/sh

echo "Press Ctrl+C to exit or type something"
while read USER_INPUT_LINE
do
    echo "Yout typed: ${USER_INPUT_LINE}"
done

```


#### Цикл `for`

**Синтаксис:**

```
for ИМЯ in СПИСОК
do
    НАБОР КОММАНД
done
```

**Пример использования:**

```
#!/bin/sh

echo "Program arguments are:"

for ARGUMENT in $*
do
    echo " ..... $ARGUMENT"
done

```

### Команда `[`

`[` - это *программа*, которая располагается в `/usr/bin`, предназначенная
для формирования логических выражений в виде `[ ВЫРАЖЕНИЕ ]`. В завимости
от результата проверки аргументов, возвращает нулевой либо ненулевой код
возврата, предназначенный для операторов `if` или `while`.

**Внимание!** В отличии от оператора присваивания, символ `=` и другие
символы сравнения являются аргументами команды `[`, и должны
отделяться пробелом.

#### Проверка строковых значений
 * `-n СТРОКА` - истина, если длина строки ненулевая
 * `-z СТРОКА` - истина, если строка пустая
 * `СТРОКА1 = СТРОКА2` - истина, если строки равны
 * `СТРОКА1 != СТРОКА2` - истина, если строки различные

#### Проверка численных значений
 * `ЧИСЛО1 -eq ЧИСЛО2` - числовое равенство
 * `ЧИСЛО1 -ne ЧИСЛО2` - числовое равенство
 * `ЧИСЛО1 -gt ЧИСЛО2` - ЧИСЛО1 > ЧИСЛО2
 * `ЧИСЛО1 -ge ЧИСЛО2` - ЧИСЛО1 >= ЧИСЛО2
 * `ЧИСЛО1 -lt ЧИСЛО2` - ЧИСЛО1 < ЧИСЛО2
 * `ЧИСЛО1 -le ЧИСЛО2` - ЧИСЛО1 <= ЧИСЛО2

#### Часто используемые проверки аттрибутов файлов
 * `-e ИМЯФАЙЛА` - указанный путь существует
 * `-d ИМЯФАЙЛА` - указанный путь существует и является каталогом
 * `-f ИМЯФАЙЛА` - указанный путь существует и является обычным файлом


### Команды `read` и `printf`

Для ввода-вывода данных (в основном - при написании скриптов) используются
команды `read` и `printf`

Команда `read` читает одну строку (до символа `\n`)из потока ввода,
и сохраняет ее значение в указанной переменной:

```
read SOME_VAR  # пользователь вводит строку
echo ${SOME_VAR}
```

Если поток данных завершился до ввода строки, то возвращается не нулевой
код возврата. Это можно использовать для огранизации цикла `while`.

Для вывода значений переменных, помимо команды `echo`, можно использовать
форматный вывод, аналогично Си:

```
A=123
B=3.14159
C=Text
D="Hello, World"  # D - содержит СПИСОК из двух слов, а не строку!
printf "%d -- %f\n%s\n%s\n" $A $B $C "$D"  # обратите внимание на кавычки
```


# Домашнее задание

Написать shell-скрипт, который выполняет очистку "мусорных" файлов в
соответствии с набором заданных шаблонов имен.
Скрипт должен принимать один аргумент: имя каталога, который
необходимо очистить; набор шаблонов передается скрипту в виде потока
ввода.

При реализации нужно использовать циклы и условия. Использование команды
`find` запрещено!

Шаблоны задаются в текстовом виде: каждый шаблон - на отдельной строке.
Входной поток может содержать "комментарии" - строки,
начинающиеся с символа `#`.


# Дополнительное домашнее задание

Пройти как можно больше уровней в игре Bandit [http://overthewire.org/wargames/bandit/].

