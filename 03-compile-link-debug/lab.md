## Цель семинара
  * Понять: общую схему трансляции и запуска программ в операционной системе.
  * Научиться: компиляции и сборке программ на C++, состоящих из одного или нескольких файлов; отладке программ в среде Linux.

## Содержание семинара
  1. Исполняемый файл, запуск исполняемого файла операционной системой.
  2. Компиляция .cpp -> .o. Флаги компиляции.
  3. Препроцессор, заголовочные файлы, директива #include.
  4. Компоновка (линковка) исполняемого файла. Использование динамических и статических библиотек.
  5. Отладка программы с помощью gdb. Точки останова (breakpoints). Способы запуска отладчика.
  6. ~~Гадание~~ Отладка по coredump.

## Теоретическая справка

Процесс компиляции C/C++ можно разбить на 3 фазы:

1. Препроцессинг. На этой фазе обрабатываются *директивы препроцессора* - строки файла, начинающиеся с символа `#`. Две основные директивы:
  * `#include "file.h"` - заменяется на содержимое файла `file.h`. Важно понимать, что `#include` всего лишь подставляет
  один файл в другой. Например, если подключить один и тот же файл 2 раза, это скорее всего приведёт к ошибкам компиляции.
  Для решения этой проблемы применяются include guards или деректива `#pragma once`.
  * `#define FOO bar` - заменяет все встречи строки символов `FOO` в файле, на строку `bar`.
  Пример:

  math.h
  ```
  #define PI 3.1415

  double sin(double x);
  ```
  math.cpp
  ```
  #include "math.h"

  double cos(double x) {
      return sin(x + PI / 2);
  }
  ```
  math.cpp после обработки препроцессором
  ```
  double sin(double x);

  double cos(double x) {
      return sin(x + 3.1415);
  }
  ```

  **Важно**: использование `#define`-ов (макросов) в C++ является признаком плохого кода, так как макросы ухудшают читаемость кода.

2. Компиляция (трансляция). На этой фазе, выход препроцессора преобразуется в машинный код. Результатом компиляции являются
  *объектные файлы*.

  Чтобы скомпилировать файл, нужно выполнить команду `g++ my_file.cpp -c -o my_file.o`.
  * `-o my_file.o` - результат компиляции нужно записать в файл `my_file.o`.
  * `-c` - только компилировать. Без этой опции gcc попытается сразу сделать исполняемый файл.

  Компилятору можно передавать дополнительные флаги, например:
  * `-Wall` - печатать предупреждения, об опасных конструкциях в коде.
  * `-O2` - включить оптимизации. По умолчанию код собирается без оптимизаций. Код, собраный с оптимизациями работает значительно быстрее.
  * `-fPIC` - собрать Positional Independent Code. Необходимо для сборки shared библиотек.
  * `-std=c++11` - включить стандарт C++11.
  * `-g` - добавляет в выходной файл отладочную информацию.
  * `-Ipath` - добавляет путь `path` в список путей поиска заголовочных файлов.

3. Линковка (связывание). На этом этапе объектные файлы объединяются в исполняемый файл или shared библиотеку.

  Чтобы получить исполняемый файл из нескольких объектных файлов, нужно выполнить команду
  `g++ my_file.o other_file.o -o myprog`

  Затем его можно запустить:
  `./myprog`

  <!---
  *NOTE* Символ `./` означает путь относительно текущего каталога в консоли. По умолчанию
  система ищет исполняемый файл в каталогах `/usr/bin` и `/usr/local/bin`. Для запуска файлов из
  других каталогов необходимо либо набирать полный путь вида `/home/vasya/myprog`, либо указывать
  путь относительно текущего каталога.
  -->

  Чтобы выполнить линковку с библиотекой, нужно указать ключ `-lmylib`, где `mylib` --- имя
  библиотеки, с которой нужно выполнить линковку. При этом библиотека должна находиться в списке
  путей поиска библиотек.


<!---
**TODO:** картинка про стадии компиляции.
-->

Для отладки исполняемых файлов существуют отладчики. В среде Linux есть стандартный консольный отладчик gdb. Управление отладчиком происходит через командный интерфейс (список самых частых команд приведен ниже).
Отладчик gdb можно использовать в трех режимах:

1. Запускать в нем исполняемый файл

 `gdb ./myprog`

 После того, как отладчик загрузил исполняемый файл и готов к работе, можно запустить исполняемый
 файл.
 В командной строке gdb наберите

 `> run`

3. Отладка при помощи [дампа
   памяти](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BC%D0%BF_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8) процесса (coredump).

 Как правило, дамп памяти сохраняется, когда процесс завершается из-за критической ошибки (например,
 ошибки сегментации). В этом случае, проанализировав дамп памяти, иногда можно понять, что послужило
 ошибкой.

 `gdb myprog /path/to/core`

 По умолчанию Linux сохраняет дампы памяти в директорию `/proc/sys/kernel/core_pattern`.

 <!---
 TODO: проверить core_pattern
 -->


 Чтобы система сохраняла дамп памяти в случае завершения процесса из-за критической ошибки, нужно
 выполнить

 `ulimit -c unlimited`


2. Присоединяться к запущенному процессу

 Если процесс запущен и работает (например, это системный демон или web-сервер),
 то можно при помощи отладчика, например, посмотреть на его состояние,
 поставить точку останова в определенной функции.

 Для этого необходимо узнать идентификатор процесса PID, к которому мы хотим подключиться, а затем
 выполнить

 `gdb --pid PID`

 Либо можно запустить `gdb`, а в его командной строке выполнить

 `gdb attach PID`

 Команду `run` при этом выполнять не нужно.

 Для отладки запущенного процесса необходимо обладать правами не ниже, чем права запущенного процесса.

 Часто используемые команды отладчика gdb (указан длинный и короткий варианты команды, использовать
 можно любой):
 * `backtrace`, `bt` -- просмотреть стек вызовов;
 * `print x`, `p x` -- просмотреть значение переменной `x`;
 * `display x` -- отображать значение выражения `x` каждый раз при остановке программы;
 * `break`, `b` -- поставить точку останова (breakpoint). Дойдя до этой точки, выполнение процесса
  прервется, вы снова получите доступ в командную строку `gdb`;
 * `next`, `n` -- перейти к следующей строке программы;
 * `list`, `l` -- просмотреть исходный код текущей строки программы и 50 строк после нее;
 * `continue`, `c` -- продолжить выполнение;
 * `step`, `s` -- перейти внутрь функции, находящейся на текущей строке;
 * `finish` -- вернуться на уровень выше (выйти из функции);
 * `help`, `h` -- показать справку, из которой можно узнать другие полезные команды.

## Задание

0. Склонируйте репозиторий http://github.com/hseos/sem-03.git.

1. В файле `bc.cpp` реализован калькулятор арифметических выражений. Он представляет из себя простой REPL.
  Сначала по входной строке строится дерево разбора (функция `Parse()`), затем это дерево вычислется (фукция `Eval()`).
  В файле `ast.h` находятся определения структур, из которых состоит дерево разбора (**не путать с деревом поиска!**).

  Скомпилируйте файл `bc.cpp` и запустите получившийся исполняемый файл. Вычислите значение выражения 1 + 2 * 3.

  *Note: В калькуляторе используется класс `std::unique_ptr`, появивившийся в стандарте c++11. Чтобы файл скомпилировался,
  нужно указать компилятору опцию `-std=c++11`.*

  *Note: Для выхода из калькулятора используйте сочетание клавиш Ctrl+C.*

2. Логику работы необходимо отделить от обработки входных данных и вывода результата и выделить в отдельный файл.
  Поместите функции `Parse()` и `Eval()` в файл `calc.cpp` и прототипы этих функций в `calc.h`. Скомпилируёте файлы `calc.cpp` и `bc.cpp` в
  один исполняемый файл. Убедитесь, что калькулятор запускается.

3. В файле `calc_test.cpp` находятся юнит-тесты. Тесты используют библиотеку gtest.
  Скомпилируйте файлы `calc_test.cpp` и `calc.cpp` вместе с библиотекой `gtest/libgtest.a` в один исполняемый файл. Запустите тесты,
  убедитесь что они проходят.

  *Note: Библиотека gtest использует системную библиотеку pthread. Чтобы подключить её, нужно добавить флаг -lpthread.*

4. Запустите исполняемый файл и вычислите значение выражения 42 / 0. Что произошло с программой?
  Запустите программу под отладчиком и снова вычислите значение выражения 42 / 0. Можете ли Вы найти строку программы, в которой происходит ошибка?

  Пересоберите калькулятор с отладочной информацией, снова запустите программу под отладчиком. Найдите строчку в программе, на которой происходит ошибка.

  Измените программу так, чтобы вместо деления на ноль она бросала исключение. Добавьте тест, проверяющий что программа больше не падает.

5. Что делать, если программа падает, но у вас нет входных данных, на которых это происходит?
  Включите запись coredump. Затем запустите скрипт compute.sh.
  Запустите отладчик на получившимся core файле. Найдите строчку в программе, на которой произошла ошибка.
  Исправьте ошибку. Добавьте тест, проверяющий что ошибка исправлена.

<!---
**TODO:** инструкция по сдаче лабы на автоматическую проверку.
-->

## Дополнительное задание
Линковка может происходить не только на этапе компиляции, но и в момент запуска программы. Этот случай называют *динамической* линковкой.
Вы уже видели, как можно указать, что к программе нужно прилинковать динамическую библиотеку (флаг -lpthread). При встрече этого флага, компилятор
вставляет в исполняемый файл информацию, которая используется динамическим линковщиком. Эту информацию можно посмотреть в любой момент, с помощью
команды ldd (посмотрите, какие динамические библиотеки использует python).

Существует возможность в момент запуска прилинковать динамическую библиотеку, даже если её не указывали в момент компиляции. Для этого используется
переменная окружения `LD_PRELOAD`. Например: `LD_PRELOAD=libmyoverrides.so ./bc`. При этом, если в динамической библиотеке будут объявлены какие-то
функции, которые уже есть в исполняемом файле, будут использованы реализации функций из динамической библиотеки. Это позволяет менять поведение
уже скомпилированных программ.

Запустите файл `my_login`. Для своей работы он просит пароль. Вам не известно, по какому алгоритму определяется валиндость пароля, зато известно,
что этой проверкой занимается функция с сигнатурой `bool is_password_valid(char* passwd);`. Напишите реализацию функции, которая считать любой пароль
правильным. Скомпилируйте файл с этой функцией в динамическую библиотеку. Загрузите библиотеку с помощью `LD_PRELOAD` и добейтесь того, чтобы программа
приняла пароль.

<!--
**TODO** Бинарник для доп задания
-->

## Вопросы

1. Напишите команду, которая скомпилирует файлы `a.cpp`, `a.h` и `b.cpp` в один исполняемый файл.
2. Почему нельзя скомпилировать файлы bc.cpp calc.cpp и bc_test.cpp в один исполняемый файл?
3. Можно ли линковать вместе объектные файлы, собранные с разными уровнями оптимизации?
4. Почему нельзя писать тело функции в заголовочном файле?
5. В чем преимущество отладки по coredump-у перед отладкой работающего процесса? В чем состоят недостатки?
6. Можно ли include-ить .cpp файлы?
7. Должен ли .h файл содержать синтаксически корректную программу?
