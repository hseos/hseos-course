# Указатели на функции

## Квалификатор `const`

При определении переменной её тип может дополняться так называемыми квалификаторами (qualifiers).
Язык Си определяет три квалификатора `const`, `volatile` и `restrict`.
Квалификаторы `volatile` и `restrict` будут рассмотрены позднее.
Квалификаторы могут стоять на любом месте в спецификации типа: до имени типа, после имени типа, и даже в середине имён типов,
состоящих из нескольких ключевых слов, например:

```
const unsigned long
unsigned long const
unsigned const long
```

— все правильные спецификации типа и описывают один и тот же тип. Однако, предпочтительнее использовать `const unsigned long`.

Квалификатор `const` означает, что определяемый объект не может быть модифицирован, потому что например, находится в ПЗУ
или в памяти, запись в которую запрещена операционной системой.

```
const int nproc = 30;
```

определяет переменную nproc типа int, которая не может быть модифицирована в данной
единице компиляции. <b>Переменная, описанная с квалификатором `const`, не может быть использована в константных выражениях</b>,
которые, в частности, задают количество элементов массива. Следующий фрагмент не является правильным в языке Си:

```
const int N = 10;
double arr[N];
```

Правильный, хотя и не очень эстетичный способ определения констант периода компиляции в Си --- ключевое слово `enum`:

```
enum { N = 10 };
```

Если квалификатор `const` используется для определения переменной-указателя,
его семантика меняется в зависимости от того, где он расположен: до символа * или после него.
Определение

```
char *ptr;
```

вводит указатель ptr, который и сам может изменяться, и память по адресу, на который
указывает данный указатель, также может быть изменена.

```
char const *ptr;
```

определяет указатель ptr на неизменяемую область памяти. Сам указатель может изменяться.

```
char * const ptr;
```

определяет неизменяемый указатель на изменяемую область памяти.

```
char const * const ptr;
```

определяет неизменяемый указатель на неизменяемую область памяти.
Из всех вышеперечисленных комбинаций чаще всего используется `const char *`.
Такой тип, например, имеют параметры многих стандартных функций. Например, функция
`strcmp` определена следующим образом:

```
int strcmp(const char *sl, const char *s2);
```

Ключевое слово `const` здесь является частью <i>контракта</i> между функцией и ее окружением, оно показывает всем пользователям
функции `strcmp`, что области памяти, на которые указывают `s1` и `s2` не будут модифицированы. Компилятор может расчитывать
на это для выполнения оптимизаций, а программист может предполагать, что строки `s1` и `s2` не изменятся.

При передаче параметров и возврате значения не имеет смысла писать `const char * const` или `const int`, например,

```
const int process(const int len, const char *const str);
```

Лишние `const` ничего не дают с точки зрения <i>контракта</i> функции, так как параметры при передаче в функцию копируются,
как и возвращаемые значения при выходе из функции. Поэтому правильно писать:

```
int process(int len, const char *str);
```

## Деклараторы

Объявление переменных в Си/Си++ состоит из базового типа, идентификатора объявляемой переменной и разных модификаторов. Например,

```
int a;                         // базовый тип - int
const unsigned long long *ptr; // базовый тип - const unsigned long long
double *ptr[10];               // базовый тип --- double
```

На самом деле конструкции, модифицирующие тип, такие как указатели, массивы, функции комбинируются в синтаксической конструкции,
называемой «декларатором». Таким образом, полное определение переменной выглядит следующим образом:

```
<базовый тип> <декларатор> [ = <инициализатор> ];
```

Декларатор содержит имя определяемого объекта, но в некоторых местах может быть «анонимным», то есть не содержащим имя определяемого объекта.
Анонимные деклараторы допускаются в операции приведения типа и при описании формальных параметров в прототипах функций.
Пример декларатора:

```
char (*(*x[3])())[5];
```

Анонимный декларатор может выглядеть следующим образом:

```
char (*(*[3])())[5];
```

Такая (на первый взгляд «странная») форма определения производных типов на самом
деле введена по аналогии с выражениями. Декларатор можно рассматривать как некоторое
выражение над типом. В таком выражении есть три операции:

|  OP  |   приоритет | описание                                 |
|------|-------------|------------------------------------------|
| `[]` | постфиксная | массив из заданного количества элементов |
| `()` | постфиксная | функция с заданными параметрами          |
| `*`  | префиксная  | указатель                                |
| `()` |             | группировка членов в выражении           |

Постфиксные операции имеют самый высокий приоритет и читаются слева направо от определяемого имени.
Префиксная операция имеет более низкий приоритет и читается справа налево.
Скобки могут использоваться для изменения порядка чтения.

Таким образом, декларатор читается, начиная от имени определяемого объекта следуя
правилам приоритетов операций. Имя определяемого объекта — это первое имя (идентификатор) после базового типа.
Примеры:

 decl           | описание
----------------|-------------------
`int a[3][4];`  | массив из 3 элементов типа массива из 4 элементов типа int (матрица 3 × 4 целых)
`char **b;`     | указатель на указатель на char
`char *c[];`    | массив из неопределённого количества элементов типа указатель на тип char
`int *d[10];`   | массив из 10 элементов типа указатель на тип int
`int (*e)[10];` | указатель на массив из 10 элементов типа int
`int *f();`     | функция, возвращающая указатель на int
`int (*g)();`   | указатель на функцию, возвращающую int
`int *(*g)();`  | указатель на функцию, возвращающую указатель на int

##Класс декларации typedef

Чтобы не нагромождать деклараторы и облегчить их чтение, введено специальное ключевое слово `typedef`.
Оно записывается перед именем базового типа в декларации, например

```
typedef int *pint;
```

В этом случае имя `pint` определяется как синоним для типа `int *`,
то есть далее в определениях переменных это имя можно использовать наравне с именем базового типа, например

```
pint a[10], f(), *p;
```

Конструкция `typedef` не вводит новый тип, а задаёт ещё одно имя для типа, которое может
использоваться наравне со старым. Поэтому переменная `pint a;` и переменная `int *b;`
имеют один и тот же тип `int *`.

Если есть `typedef`-имя и декларация, использующая это имя, то от `typedef`-имени
можно избавиться, подставив декларируемое имя вместо `typedef`-имени в `typedef`-декларацию
и добавив при необходимости скобки для того, чтобы порядок чтения не изменился. Например,

```
typedef void (*pfunc)(int);
pfunc signal(int, pfunc);
```

после преобразования получаем

```
void (*signal(int, void (*)(int)))(int);
```

## Указатели на функции

Декларатор вида

```
int (*pfunc)(int a, int b);
```

читается следующим образом: `pfunc` --- это указатель на функцию, принимающую два параметра типа `int` и возвращающую значение типа `int`.
То есть `pfunc` --- это переменная <b>указатель на функцию</b>. С помощью `typedef` переменная может быть объявлена следующим образом:

```
typedef int (*func_t)(int a, int b); // func_t - тип указателя на функцию
func_t pfunc;
```

Любая переменная-указатель на функцию может принимать значение `NULL` (или 0, или nullptr в Си++).
Если переменная-указатель на функцию не равна NULL, она должна <i>указывать на</i> функцию,
совместимую по передаваемым параметрам и возвращаемому значению.

Операция взятия адреса `&`, примененная к имени функции, дает значение типа указателя на функцию
с соответствующим количеством и типом параметров и типом возвращаемого значения, например,

```
int handler(int value, int mask);

    &handler   // даст значение типа int (*)(int, int)
```

Однако, для имен функций автоматически выполняется неявное преобразование имени функции в указатель на функцию.
То есть,

```
pfunc = handler;
```

это то же самое, что

```
pfunc = &handler;
```

Поэтому, как правило, явную операцию взятия адреса перед именами функций не пишут.

Операция разыменования `*`, примененная к указателю NULL или к указателю, не указывающему на функцию,
совместимую по передаваемым параметрам и возвращаемому значению, дает <b>неопределенное поведение</b>
(undefined behavior). Как обычно, компилятор имеет право исходить из предположения, что в программе
при ее выполнении никогда не возникает неопределённое поведение, и оптимизировать программу соответственно.

Если указатель на функцию корректен, то операция разыменования дает в результате значение (точнее, function designator),
к которому применима операция вызова функции. Например,

```
    int z = (*pfunc)(10, 20);   // будет вызвана функция, на которую в данный момент указывает pfunc
```

Если указатель на функцию используется там, где требуется function designator, он неявно разыменовывается. Таким образом,
явная операция `*` для вызова функции по указателю не нужна и часто опускается.

```
    int z = pfunc(10, 20);     // то же, что и выше
```

Поэтому по виду операции вызова функции бывает сложно определить, вызывается ли функция напрямую или через указатель.

## Массивы

Массив в Си/Си++ - это **непрерывная** область памяти, в которой подряд хранятся элементы одного типа.

```
int arr1[16];
```

Размер массива равен произведению размера одного элемента на количество элементов. То есть
`sizeof(arr1) = 16 * sizeof(int)`.

Количество элементов в определении массива можно не указывать, если его можно определить из инициализатора массива.

```
int arr2[] = { 1, 2, 3 }; // размер массива равен 3
```

Массив не может содержать отрицательное число элементов, но массивы с нулем элементов допустимы.
Их размер равен 0, и они полезны в некоторых ситуациях.

Массив нельзя возвращать из функции. Если массив передается в качестве параметра в функцию,
то фактически будет передаваться указатель на начало массива. При передаче массива в качестве
параметра он не копируется.

В контекстах, где компилятору не нужно знать размер массива (например, при передаче параметров)
самый левый размер может опускаться.

```
void func1(int a[], double b[][10]);
```

Поскольку фактически передается адрес начала массива, то модификация параметров функции будет
видна извне, так как будет модифицирован массив, адрес начала которого был передан.

Массив индексируется целым числом. Начальный элемент массива имеет индекс 0, последний
элемент массива имеет индекс `count - 1`, где `count` число элементов массива.
Обращение к элементам за пределами массива ненулевого размера (отрицательными или >= count) - undefined behavior.

## Указатели

У любого указательного типа есть специальное значение `NULL`. Везде, где требуется указательный тип,
компилятор умеет преобразовывать целое число 0 ко значению `NULL`. Везде, где требуется булевское
значение (например, в условиях `if`) значение `NULL` считается ложным значением, а любое другое значение - истинным.

Однако, не гарантируется, что битовое представление указателя `NULL` содержит все нулевые биты, например, NULL
не равный всем нулевым битам возможен на процессорах с несколькими адресными пространствами.
Тем не менее, на всех типичных микропроцессорных архитектурах
(x86/x64, ARM, PPC, MIPS, SPARC) указатель `NULL` содержит все нулевые биты. Обращение по указателю `NULL` -
undefined behavior. Поэтому компилятор может предполагать, что если некоторая указательная переменная была
разыменована, она не равна `NULL`.

```
    *p = 0;
    if (!p) { // эта проверка и весь код могут быть удалены
        fprintf(stderr, "NULL pointer\n");
    }
```

Пусть дан массив некоторого типа `T` с количеством элементов `C`:
```
T arr[C];
```

Арифметические операции над указателями определены в терминах операций над индексами массива.

Само по себе имя массива `arr`, использованное в выражении, неявно преобразовывается в указатель
на начальный элемент массива.
```
T *p = arr; // то же самое, что *p = &arr[0];
```

Если указатель `p` указывает на элемент с индексом `i` (`p = &arr[i]`), то
`p + j` (прибавление целого числа к указателю) - это то же самое, что
`&arr[i + j]`. Аналогично `p - j` (вычитание целого числа из указателя) - это `&arr[i - j]`.
Если результирующий индекс `i + j` или `i - j` окажется отрицательным или большим `C`,
то результат - undefined behavior. Однако указатель на элемент, непосредственно
следующий за последним элементом массива (`&arr[C]`) допустим, хотя его нельзя
разыменовывать. Эти правила применимы также и к операциям `+=`, `-=`, `++`, `--`
над указателями.

Если указатель `p` указывает на элемент с индексом `i`, а указатель `q` - на элемент
с индексом `j` в том же самом массиве, то
```
    q - p == &arr[j] - &arr[i] = j - i
```
Если указатели указывают на элементы разных массивов - undefined behavior.
Таким образом, разность двух указателей дает разность в терминах количества
элементов массива, расположенных между этими указателями.

Операция обращения по индексу `p[i]` применима к массивам и указателям
и обозначает по определению `*(p + i)`. Если `p` указывает
в середину массива, то вполне допустимы и отрицательные индексы,
при условии, что не происходит выхода за пределы массива.

## Представление строк в Си

Строки в Си (не путать с Си++) очень часто представляются
в формате простого массива `char*`, последнее значение
которого равно `'\0'`.

Такие строки размещаются в памяти как непрерывный массив
байт. Символ с кодом `0` может встречаться в середине этого
массива. В таком случае функции, которые предназначены
**для работы со строками** будут считать этот символ концом
строки, несмотря на то, что размер массива может быть больше,
и данные после `'\0'` легко доступны.

Указатель на символ (`char *`) определяет адрес первого
символа в строке. Все остальные символы могут быть получены
инкрементом (эквивалентно - оператором `[]`) этого указателя
на заданное смещение.


```
static const char * Hello = "Hello, World!";

char first  = *Hello;        // first  = 'H'
char second = *(Hello + 1);  // second = 'e'
char third  = Hello[2];      // third  = 'l'
char last   = Hello[12];     // last   = '!'
char nullval= Hello[13];     // nullval = 0;

```

Ввиду непрерывности размещения строки в памяти, инкремент
указателя на единицу приводит к тому, что он становится
указателем на следующий символ.


```
static const char * Hello = "Hello";

for ( const char * substring = Hello;
      '\0' != *substring;
      ++substring )
{
   printf("%s\n", substring);
}

/* Вывод на экран:
Hello
ello
llo
lo
o
*/

```

В данном примере исходная строка не изменяется, а на экран
выводятся ее подстроки, получаемые сдвигом указателя на один
символ вперед. Обратите внимание, что переменная цикла
объявлена как `const char*`. В данном случае модификатор
`const` относится не к переменной `substring`, значение
которой изменяется, а к типу данных `char*`, то есть нельзя
изменять содержимое, на которое ссылается указатель.

Если требуется объявить неизменяемость самого указателя,
необходимо писать `const` после символа `*`.


```
const char * immutable_string    = "You can't modify me!";
char * const immutable_pointer   = "Value can be changed, but pointer not";
const char * const immutable_all = "Everything protected from changes";
```

## Хранение строк

Если определяется массив элементов `char`, который инициализируется строковым литералом,
то указанная строка будет размещена в массиве.

```
char str[] = "Hello";
```

Размер массива `str` будет равен 6 (5 значащих символов + `\0`-терминатор строки).
В его элементах последовательно будут размещены символы строки.
Элементы массива могут быть модифицированы.

```
    str[4] = 0;
    printf("%s", str); // получим Hell
```

Можно размещать строку в константном массиве.
```
const char str[] = "Hello";
```

В этом случае простые попытки модификации строки будут диагностированы и
запрещены компилятором. Массив `str` вполне возможно будет размещен
в памяти, закрытой на запись, и попытка обойти ограничение компилятора
приведет к падению программы.

```
    *(char*) str = 'h';  // получим segmentation fault
```

В этих двух случаях понятно, в какой области памяти будет размещена строка.
Но рассмотрим следующий пример:
```
void func(void)
{
    const char *p = "abcdefghijkl";
    // ...
}
```

Локальная переменная `p` - это указатель, она содержит адрес начала строки,
но где размещается сама строка? Этот фрагмент эквивалентен примерно
следующему:
```
static const char anonstr[] = "abcdefghijkl";
void func(void)
{
    const char *p = anonstr;
    // ...
}
```

Содержимое строки размещается в некотором массиве в памяти, доступной только на чтение,
а адрес начала массива присваивается переменной `p`. Поэтому попытка
обойти ограничения и модифицировать строку тоже приведет к падению программы.

## Обработка строк

Если программа обрабатывает строковые данные, то вряд ли в ней можно обойтись только
константными строками. Программа должна считать строковые данные откуда-то извне,
их обработать, затем записать результат. Мы будем предполагать, что обрабатываются
текстовые файлы, то есть файлы, не содержащие байт `\0`, поэтому для работы с такими
файлами можно использовать функции стандартной библиотеки языка Си.

Считанная строка должна быть размещена в памяти. Это может быть глобальный массив,
локальный массив или область памяти, выделенная динамически. В любом случае
это будет область памяти ограниченного размера. Назовем такую область памяти,
предназначенную для хранения строки, *буфером* строки. Буфер строки имеет два параметра:
указатель на начало буфера и размер буфера. Если размер буфера равен N, то в буфере
не может размещаться строка, длина которой больше N - 1, так как один байт займет символ \0
терминатор строки.

Таким образом, мы будем различать следующие понятия: строка - это цепочка байт,
заканчивающаяся байтом \0. Буфер - это область памяти, отведенная для хранения строки.

Если требуется написать функцию, которая обрабатывает строку, и результатом обработки
тоже является строка, возможны следующие варианты.

Иногда возможно обработать строку "на месте". То есть функция принимает указатель
на начало строки и модифицирует ее в соответствии с требованиями. В этом случае
неявно предполагается что размер буфера обрабатываемой строки равен длине строки + 1.
В таком случае нормально, если строка уменьшится в размере, но **недопустимо увеличение
ее размера**.

Например, рассмотрим функцию, которая преобразовывает все символы во входной строке
к нижнему регистру:
```
void tolowerstr(char *s)
{
    for (char *p = s; *p; ++p) {
        *p = tolower(*p);
    }
}
```

Используется функция `tolower`, преобразовывающая к нижнему регистру один символ,
переданный ей в качестве аргумента.

Более универсален вариант, когда в качестве результата работы функции возвращается
строка, буфер под которую выделен в динамической памяти с помощью функций
`malloc` или `realloc`. Например, рассмотрим функцию, выполняющую конкатенацию двух
входных строк:

```
char *concatenate(const char *str1, const char *str2)
{
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    char *ret = malloc(len1 + len2 + 1); // не забываем \0-байт
    if (ret) {
        memcpy(ret, str1, len1);
        memcpy(ret + len1, str2, len2 + 1);
    }
    return ret;
}
```

Функция предполагает, что аргументы `str1` и `str2` не могут быть указателями NULL.
В аргументах используется ключевое слово `const`, чтобы показать,
что строки не модифицируются функцией `concatenate`.

Функция `malloc` выделяет заданный объем памяти в куче и возвращает указатель на начало.
Если `malloc` не смогла выделить память, возвращается `NULL`.
Выделенная память используется как буфер для хранения строки.

Функция `memcpy(dst,src,size)` копирует `size` байт с места в памяти, на которое указывает
`src` на место, на которое указывает `dst`. **Буфера в памяти не должны перекрываться.**

Такая функция `concatenate` всем хороша. Важно не забыть освободить выделенную память
с помощью функции `free`. Кроме того, динамическое выделение и особождение памяти - операция сложная
и займет существенное время, если обрабатывается много коротких строк.

Часто используется еще один вариант возврата обработанной строки. В этом случае функция,
обрабатывающая строку, принимает на вход два параметра буфера: адрес начала и размер.
Функция записывает в буфер строку-результат. Если строка окажется длиннее, чем
размер буфера - 1, она обрезается. В любом случае в выходной буфер дописывается
\0 байт терминатор строки. Функция может каким-либо образом сигнализировать
о том, что буфер переполнился, например, с помощью возвращаемого значения.

```
size_t concatenate(char *buf, size_t size, const char *str1, const char *str2)
{
    // здесь реализация
}
```

Эта гипотетическая функция может возвращать суммарную длину строк `str1` и `str2`.
В буфер `buf` записывается конкатенация двух строк, но не более чем `size` - 1 символ.

Если функция принимает только один параметр для записи строки-результата - адрес буфера, при этом невозможно
контролировать длину строки, которая будет записана в этот буфер, такую функцию использовать
*крайне опасно* (по меньшей мере). Например, функция `gets`, которая считывает одну строку из
стандартного потока ввода и сохраняет ее по указанному адресу, безусловно запрещена к использованию.

## Чтение строки

Для чтения одной строки из текстового файла используется функция `fgets`.
```
    char *fgets(char *buf, size_t size, FILE *fin);
```

Функция возвращает `NULL` при ошибке чтения или достижении конца файла.
В противном случае функция возвращает указатель `buf`.

Функция считывает одну строку текста из файла `fin`.
Строка текста заканчивается либо символом '\n', либо концом файла,
либо исчерпанием места в буфере `buf`. Если символ \n считан, он помещается в буфер.
В любом случае считывается не более чем size - 1 символ из входного файла.

Функцию допустимо использовать, когда есть ограничение на максимальную длину строки текста
во входном файле.


У функций семейства `scanf` есть форматное преобразование `%s`. Оно требует
указатель на буфер строки.
```
    char buf[64];
    scanf("%s", buf);
```

При чтении строки предварительно пропускаются все пробельные символы, чтение в строку
ведется либо до конца файла, либо до первого пробельного символа.
Использование преобразование %s в этом виде не позволяет контролировать число
считанных символов, поэтому **использование `%s` в таком виде недопустимо**.
Необходимо указать максимальное число считываемых символов следующим образом:

```
    char buf[64];
    scanf("%63s", buf);
```

## Вывод строки

Строку можно вывести с помощью спецификации `%s` функции семейства `printf`.
Например,

```
    printf("%s", buf);
```

Если выводится только строка, можно использовать fputs
```
    fputs(buf, stdout);
```

**Запрещено выводить строку с помощью `printf` без явного указания формата**
```
    printf(buf); // недопустимо
```

## Форматное преобразование в строку

Для форматного вывода данных в строку предназначена функция `snprintf`.
```
    int snprintf(char *buf, size_t size, const char *format, ...);
```

`buf` и `size` задают буфер для формирования строки. `snprintf` записывает
в буфер не более чем `size` - 1 символ, всегда записывая \0 в конце.
В любом случае функция `snprintf` возвращает столько символов, сколько было
бы записано в выходной поток, если бы размер буфера `buf` был неограниченным.

Пример использования функции `snprintf`.

```
size_t concatenate(char *buf, size_t size, const char *str1, const char *str2)
{
    return snprintf(buf, size, "%s%s", str1, str2);
}
```


## Форматное чтение из строки

Для форматного преобразования из строки может использоваться функция `sscanf`.
```
    int sscanf(char *str, const char *format, ...);
```

Например,
```
    sscanf(argv[1], "%d", &value);
```

В случае чтения из строки удобно использовать форматное преобразование `%n`.
```
    int value, n;
    int res = sscanf(p, "%d%n", &value, &n);
```

В случае успешного преобразования строки в число `sscanf` вернет 1, а в переменную
`n` будет записано число символов, считанных из строки при преобразовании в число.
После этого `p + n` - это позиция в строке, на которой остановилось чтение из файла.

## Контролируемое преобразование из строки в число

Часто требуется преобразовать строку в число целого или вещественного типа,
при этом проверить корректность записи числа. При этом требуется, чтобы
при чтении числа не возникало переполнение, в хвосте числа не находится "мусор".
Следущие записи считаются недопустимыми: "" (пустая строка), "   " (только пробельные символы в строке),
"1231a" (мусор в конце строки), "1 " (пробел в конце строки),
"11111111111111111111111111111111111111111111" (число не представимо значением
целого типа). Следущие записи допустимы: "12", "   -12" (пробелы перед числом допускаются).

Для такого рода преобразований используются функции `strtol` (чтение в long), `strtoll` (чтение в long long),
`strtoul` (чтение в unsigned long), `strtoull` (чтение в unsigned long long), `strtod` (чтение в double).
Они определены в заголовочном файле `<stdlib.h>`.

Рассмотрим использование `strtol`.
```
    long strtol(const char *str, char **eptr, int radix);
```

Функция возвращает преобразованное значение. При этом если возникло переполнение, в переменную `errno`
записывается код ошибки `ERANGE`.

В переменную, адрес которой передан вторым параметром, записывается указатель на первый символ, который не является
частю считанного числа, то есть либо адрес нулевого байта-терминатора, либо адрес начала "мусора" после числа.
Если в строке вообще нет цифр, сохраняется адрес строки str.

Параметр `radix` задает систему счисления для перевода. Он может принимать значения от 2 до 36.
Если `radix` равен 0, функция пытается определить систему счисления по правилам записи целых чисел языка Си
(по префиксу числа: 0x - шестнадцатеричное, 0 - восьмеричное, иначе десятичное).

Поэтому проверка корректности чтения с помощью `strtol` заключается в следующем:
* проверить, что строка не пуста
* проверить, что переменная `errno` не установлена
* проверить, что `eptr` указывает на нулевой байт

```
    // число записано в str
    char *eptr;
    errno = 0; // очищаем errno, так как при успехе errno не модифицируется
    long value = strtol(str, &eptr, 10);
    if (!*str || *eptr || errno) {
        // ошибка преобразования из строки в число
    }
```

# Инициализация выделенной памяти

В заголовочном файле `<string.h>` объявлена одна очень
полезная функция:

`void *memset(void *s, int c, size_t n)` - заполняет
массив из `n` байт, который находится по адресу `s`
**однобайтными** значениями `c` (от `0` до `0xFF`). Возвращает
указатель `s`.

Тип параметра `int c` сохраняется по историческим причинам,
на самом деле переданное значение преобразуется к
`unsigned char`.

Эту функцию можно (и нужно) вызывать после выделения памяти
для массива или буфера, иначе с большой вероятностью,
выделенная память будет содержать какие-то случайные значения.

# Динамическое выделение памяти

Функции динамического выделения и освобождения памяти определены
в заголовочном файле `<stdlib.h>`.

* `void* malloc(size_t n_bytes)` - выделяет память для
 хранения `n_bytes` байт, возвращает нетипизированный
 указатель на выделенную область

* `void free(void *pointer)` - освобождает память,
выделенную ранее функцией `malloc`

Функция `realloc` позволяет изменить размер уже выделенного блока:
```
void *realloc(void *oldptr, size_t newsize);
```
размер выделенного блока можно как увеличивать, так и уменьшать.
Функция старается, но не гарантирует, чтобы блок памяти остался по тому же
адресу. Поэтому расширение размера может перенести данные на другой адрес.

Функция `realloc` является основой для реализации *расширяемых массивов*
(в C++ им соответствует шаблонный класс `vector`).

В расширяемом массиве для каждого массива хранятся три переменных:
`data` - указатель на массив, `size` - число элементов, хранящихся в массиве,
`reserved` - число элементов, под которые выделена память.

Начальный размер расширяемого массива может быть нулевым, а может быть
равным, например, 32 байта.

```
    int    *data;
    size_t  size = 0;
    size_t  reserved = 32 / sizeof(*data);
    data = malloc(reserved * sizeof(*data));
```

Если при добавлении элемента в массив места в нем не осталось,
память под него перевыделяется:
```
    if (size == reserved) {
        data = realloc(data, (reserved *= 2) * sizeof(*data));
    }
    data[size++] = newvalue;
```

# Текстовые файлы

Текстовыми мы будем называть файлы, удовлетворяющие следующим ограничениям:
* не содержит байт со значением 127;
* из значений байтов в диапазоне 0-31 допускаются только символы \t, \r, \n; в частности, не допускается байт 0;
* файл состоит из строк текста. Каждая строка текста заканчивается либо байтом \n, либо байтами \r \n;
* последняя строка в файле может не заканчиваться байтами конца строки.

Пустой текстовый файл допускается и считается, что содержит 0 строк текста.
Если текстовый файл содержит единственную строку, не завершающуюся байтами конца строки, он содержит одну строку текста.

Ваша программа при чтении должна корректно обрабатывать файлы и с концами строк в стиле DOS, и с концами строк в стиле Unix.

Когда ваша программа формирует в качестве результата работы текстовые файлы, каждая строка, в том числе и последняя,
должна завершаться единственным символов конца строки \n. Использование \r в генерируемых файлах не допускается.

Стандартные потоки `stdin`, `stdout`, `stderr` по умолчанию являются текстовыми
потоками и должны подчиняться описанным выше правилам.
