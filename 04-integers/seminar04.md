# Целые типы данных C/C++

Языки C и C++ предлагают следующие типы данных.

`char` - тип, достаточный для хранения кода символа из базового набора символов. Всегда (по определению стандарта языка)
`sizeof(char) == 1`. **Является ли тип `char` знаковым или нет - зависит от компилятора!** На x86/x64 тип `char` является знаковым,
а на ARM - беззнаковым. На всех современных компиляторах `char` восьмибитный.

`signed char` и `unsigned char` типы с явным указанием знаковости.

`short` и `unsigned short` на всех современных компиляторах 16-битные.

Как правило, типы `int` и `unsigned int` - 32-битные, но для встроенных систем встречаются и 16-битные типы `int`
(например, для AVR - платформы Arduino).

С типами `long` и `unsigned long` больше всего различий: на 16- и 32-битных системах тип `long` - 32-битный.
На 64-битных системах Unix он 64-битный, а на **64-битной Windows он все еще 32-битный!**

Типы `long long`, `unsigned long long` везде, где присутствует, в настоящее время 64-битный.

Современные стандарты C и C++ предлагают заголовочный файл `<stdint.h>` или `<cstdint>` (для C++), в котором введены
типы для целых чисел фиксированной битности: int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t.
Везде, где необходимы типы с точной битностью, следует использовать этот заголовочный файл.

# Представление знаковых и беззнаковых чисел, битовые операции с числами

Посмотрите [презентацию (англ.)](http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf)

# Переполнение при выполнении операций в C/C++

Язык C не содержит встроенных средств для обнаружения переполнения при выполнении целочисленных операций.

Согласно стандарту, операции сложения и вычитания над беззнаковыми числами выполняются по модулю 2^N (N - число бит),
поэтому даже в случае переполнения результат операции определен.

Однако переполнение при выполнении операций со знаковыми числами приводит к **неопределенному поведению**
(UB - Undefined behaviour). Компилятор в этом случае волен применять любые оптимизации, например, считать,
что знаковые целочисленные операции никода не вызывают переполнения.

Игнорирование переполнений при выполнении арифметических операций может приводить к критическим дырам в безопасности системы
(примеры можно найти в презентации выше).

Поэтому некоторые компиляторы предлагают специальные функции для выполнения операций с контролем переполнения. Например,
gcc предлагает встроенные функции (intrinsic), которые описаны [здесь:](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html)

# Преобразование строки в число

Для преобразования строки в беззнаковое целое число можно использовать функцию C++ [std::stoul](http://en.cppreference.com/w/cpp/string/basic_string/stoul)

Эта функция выбрасывает исключение в случае, если первый непробельный символ не является цифрой или знаком минус,
или значение числа слишком велико, или строка содержит только пробельные символы. Но в случае, если после числа в строке
находится мусор, функция отрабатывает нормально. Чтобы обнаружить мусор после числа используйте параметр `pos`.

Альтернативным вариантом является функция [`strtoul`](http://en.cppreference.com/w/c/string/byte/strtoul) стандартной библиотеки C

Функция устанавливает переменную `errno` в случае ошибки. Так как нет специального возвращаемого значения в случае ошибки,
то перед вызовом функции переменную `errno` следует обнулить. Чтобы обнаружить наличие мусора после числа используйте параметр
`str_end`. Обратите внимание, **`strtoul` возвращает 0 на строках, состоящих только из пробельных символов**. Этот случай должен
проверяться отдельно.

# Текстовые и бинарные файлы

**Текстовым** файлом назовем файл, удовлетворяющий следующим свойствам:

* Файл состоит из строк текста. В конце каждой строки текста находится либо символ \n, либо пара символов \r\n.
Последняя строка текстового файла может не оканчиваться на символы конца строки.
* Из управляющих символов (символов с кодами 0-32 и 127) текстовый файл может содержать символы \t (табуляция), \r, \n.
В особенности, текстовый файл не содержит символа с кодом 0.
* Текст в текстовом файле хранится в какой-либо кодировке. На UNIX, как правило, используются однобайтовые кодировки, обычно в настоящее время
UTF-8. На Windows еще встречаются файлы в UTF-16.

Данные в текстовых файлах, как правило, представлены в человеко-читабельном формате. Например, 32-битное число 1234 может быть
записано в виде последовательности символов '1', '2', '3', '4'.

Наоборот, в **бинарном файле** нет никаких ограничений на хранимые байты. Нулевой байт является в бинарных файлах совершенно нормальным.
Бинарные файлы не разбиваются на строки. Данные в бинарном файле хранятся во внутреннем представлении.

На UNIX для открытия бинарных файлов не требуется специальных флагов. На Windows необходимо явно указывать, что открывается бинарный файл,
чтобы отключить трансляцию символов концов строк.

На языке C++ для открытия бинарного файла следует задавать флаг [ios::binary](http://www.cplusplus.com/reference/ios/ios_base/openmode/)

Для чтения из бинарного файла следует использовать метод [`read`](http://www.cplusplus.com/reference/istream/istream/read/) класса ifstream, а для записи - метод `write`.
