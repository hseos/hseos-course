# Ассемблер x86, часть 5

## Позиционно-независимый код

В примере вывода строки на стандартный поток вывода инструкция `push $msg1` заносит в стек **адрес** в памяти,
по которому размещается строка "Hello". При компоновке программы в исполняемый модуль будет получен такой фрагмент исполняемого файла:
```
08048460 <func>:
 8048460:	56                   	push   %esi
 8048461:	68 50 84 04 08       	push   $0x8048450
 8048466:	e8 a5 fe ff ff       	call   8048310 <printf@plt>
 804846b:	83 c4 08             	add    $0x8,%esp
 804846e:	c3                   	ret    
```

(для получения ассемблерного листинга использовалась команда `objdump --disassemble FILE`)

В этом фрагменте в инструкции вызова `call` для получения адреса, на который нужно переходить, испольуется смещение
`0xfffffea5` (байты a5 fe ff ff), а для загрузки в стек адреса строки, используется абсолютный адрес `0x08048450`
(байты 50 84 04 08).

Если мы заходим разместить исполняемый файл в памяти, начиная с другого адреса, а не с адреса `0x08048034`, инструкция `call`
останется без изменений (так как смещение не изменится при перемещении файла по памяти), а инструкция `push` потребует модификации.
Машинный код, настроенный на работу по фиксированным адресам в памяти, называется **неперемещаемым** (или позиционно-зависимым).

Такой код малопригоден для разделяемых библиотек, так как одна и та же библиотека может располагаться по разным адресам
в адресном пространстве разных процессов.

В **позиционно-независимом** (PIC) коде запрещено использование абсолютных адресов. Все адреса глобальных переменных и областей данных
должны вычисляться относительно текущего положения исполняемого кода.

Один из возможных способов реализации PIC-кода описан ниже.

Для получения текущей позиции в коде используется идиома:
```gas
        call    l1
l1:     popl    %eax
```

То есть мы "вызываем" следующую инструкцию программы, помеченную `l1`.
При этом в стек будет занесен адрес возврата (та же самая инструкция, помеченная `l1`), и затем будет
выполнен переход на саму же инструкцию, помеченную `l1`. После этого адрес инструкции достается из стека
с помощью инструкции `popl`.

```gas
        .text
msg1:   .asciz  "Hello, %d!\n"
        .align  16
        .global func
func:
        pushl   %esi            /* сразу заносим в стек второй аргумент printf */
        call    l1              /* получаем адрес, по которому размещаемся в памяти */
l1:     popl    %eax
        addl    $msg1-l1, %eax  /* прибавляем к адресу l1 смещение msg1 относительно l1 */
        pushl   %eax            /* заносим в стек получившийся абсолютный адрес */
        call    printf
        addl    $8, %esp        /* чистим стек */
        ret
```

## Global Offset Table

Когда программа скомпонована динамически, то есть когда при загрузке программы на выполнение
требуется подгрузить динамические библиотеки и обработать внешние связи в каждой из подгруженных библиотек,
для связывания загружаемых исполняемых программ и динамических библиотек используется GOT (Global Offset Table) - таблица смещений к глобальным объектам.

Таблица GOT размещается в специальных секциях исполняемого файла, которые называется `.got` и `.got.plt`.
Таблица представляет собой массив указателей, то есть на 32-битных платформах каждый элемента таблицы занимает
4 байта, а на 64-битных - 8 байт. В этот массив динамический загрузчик (например, `/lib/ld-linux.so.2`)
прописывает фактические адреса глобальных объектов исполняемых файлов и динамических библиотек,
загруженных в память.

Программа, которая использует GOT, должна сначала получить адрес GOT, затем по заданному смещению внутри GOT
получить адрес интересующего эту программу объекта (глобальной переменной или функции).
Сначала получим адрес текущей инструкции. Это можно сделать с помощью вспомогательной подпрограммы `geteip`:

```
geteip:
        mov     (%esp), %ebx
        ret
```

После возврата из этой функции в регистре %ebx будет находится адрес текущей инструкии. Затем, используя
специальное значение `_GLOBAL_OFFSET_TABLE_` получим абсолютный адрес GOT:

```
        call    geteip
        add     $_GLOBAL_OFFSET_TABLE_, %ebx
```

После выполнения этого фрагмента кода в регистре %ebx получаем абсолютный адрес начала таблицы GOT.
Обращаясь к элементам таблицы GOT мы будем получать адреса в памяти, в которых находятся подпрограммы
или переменные. Например,

```
        mov     A@GOT(%ebx), %eax
```

загрузит адрес, находящийся в элементе GOT, соответствующем глобальной переменной A, на регистр %eax.
Этот адрес нужно использовать для доступа к значению.

```
        mov     (%eax), %eax
```

Таким образом, полная последовательность инструкций для загрузки значения переменной A в регистр %eax
выглядит следующим образом:

```
        call    geteip
        add     $_GLOBAL_OFFSET_TABLE_, %ebx
        mov     A@GOT(%ebx), %eax
        mov     (%eax), %eax
```

## Косвенные переходы и вызовы подпрограмм

Для реализации операторов типа `switch`, или для реализации таблиц виртуальных функций, полезна возможность косвенного перехода или вызова подпрограммы.
Например, инструкция
```gas
        jmp     *%eax
```
выполнит переход по адресу, который располагается в регистре `%eax`, а инструкция `call *%eax` выполнит аналогичный вызов подпрограммы.

Предположим, что в регистре `%eax` передано некоторое значение от 0 до 3. Нам нужно перейти на метку `D0`, `D1`, `D2`, `D3` в зависимости о значения `%eax`.
```gas
        movl    jmptab(,%eax,4), %eax   // загружаем адрес из таблицы адресов
        jmp     *%eax                   // косвенный переход
jmptab: .int    D0, D1, D2, D3          // записываем адреса меток
```

Две инструкции можно сократить до одной:
```
        jmp   *jmptab(,%eax,4), %eax
```

Обратите внимание, что метод адресации `jmptab(,%eax,4)` позиционно-зависим. В машинном коде запишется абсолютный адрес `jmptab`.
