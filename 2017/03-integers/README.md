# Лекционный материал

Лекция 2 была посвящена целым числам. [Слайды лекции](https://github.com/hseos/hseos-course/blob/master/2017/00-lectures/02-integers/02-integers.pdf)

Дополнительная [презентация (англ.)](http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf)

# Целые типы данных C/C++

Языки C и C++ предлагают следующие типы данных.

`char` - тип, достаточный для хранения кода символа из базового набора символов. Всегда (по определению стандарта языка)
`sizeof(char) == 1`. **Является ли тип `char` знаковым или нет - зависит от компилятора!** На x86/x64 тип `char` является знаковым,
а на ARM - беззнаковым. На всех современных компиляторах `char` восьмибитный. Явным образом управлять знаковостью
`char` можно с помощью опций `-fsigned-char`, `-funsigned-char` компилятора gcc.

`signed char` и `unsigned char` типы с явным указанием знаковости.

`short` и `unsigned short` на всех современных компиляторах 16-битные.

Как правило, типы `int` и `unsigned int` - 32-битные, но для встроенных систем встречаются 8 или 16-битные типы `int`
(например, для AVR - платформы Arduino, он является 16-битным, но если указать флаг `-mint8` тип `int` становится 8-битным).

С типами `long` и `unsigned long` больше всего различий: на 16- и 32-битных системах тип `long` - 32-битный.
На 64-битных системах Unix он 64-битный, а на **64-битной Windows он все еще 32-битный!**

Типы `long long`, `unsigned long long` везде, где присутствует, в настоящее время 64-битный.

# Типы фиксированной битности

Современные стандарты C11 и C++11 предлагают заголовочный файл `<stdint.h>` или `<cstdint>` (для C++), в котором введены
типы для целых чисел фиксированной битности: int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t.
Везде, где необходимы типы с точной битностью, следует использовать этот заголовочный файл.

Не все компиляторы поддерживают этот файл. Кроме того, существование этих типов не гарантируется. Например,
некоторая (гипотетическая) платформа может вообще не поддерживать 16-битные целые числа. Тогда на ней
будут отсутствовать int16_t, uint16_t. Если язык Си не поддерживает в языке 64-битные целые типы
(например, на 8 или 16-битных микроконтроллерах), будут отсутствовать типы int64_t, uint64_t.

Поскольку отображение типов фиксированной битности на типы языка Си непрозрачно для программиста,
возникает проблема выбора правильного форматного преобразования при использовании `printf` или `scanf`.
Например, на x86_64 тип `int64_t` может отображаться как в `long`, так и в `long long`
(оба имеют размер 64 бита). Должны ли мы использовать для вывода форматное преобразование `%ld`
или использовать форматное преобразование `%lld`?

Для этого в заголовочном файле `<inttypes.h>` определены макросы, использование которых в `printf` и `scanf`
гарантирует выбор правильного форматного преобразования. Например, для вывода значения типа `int64_t` можно
использовать макрос `PRId64`, а для вывода значения типа `uint64_t` в шестнадцатеричном виде
можно использовать макрос `PRIx64` как показано в примерах ниже:

```
    int64_t val;
    printf("Result is %" PRId64 "\n", val);
    uint64_t addr;
    printf("Address: 0x%016" PRIx64 "\n", addr);
```

Обратите внимание, макросы `PRI*` заменяют собой ту часть форматного спецификатора `printf`, которая
отвечает за тип аргумента. Знак `%`, ширина поля вывода, тип преобразования должны быть указаны явно.

Перечисление доступных макросов есть, например, (здесь)[http://en.cppreference.com/w/cpp/types/integer].

Альтернативным (возможно, менее переносимым) решением при выводе 64-битных значений
будет использование явного приведения типа к `long long` или `unsigned long long`, например,

```
    int64_t val;
    printf("Result is %lld\n", (long long) val);
    uint64_t addr;
    printf("Address: 0x%016llx\n", (unsigned long long) addr);
```

# Переполнение при выполнении операций в C/C++

Язык C не содержит встроенных средств для обнаружения переполнения при выполнении целочисленных операций.

Согласно стандарту, операции сложения и вычитания над беззнаковыми числами выполняются по модулю 2^N (N - число бит),
поэтому даже в случае переполнения результат операции определен.

Однако переполнение при выполнении операций со знаковыми числами приводит к **неопределенному поведению**
(UB - Undefined behavior). Компилятор в этом случае волен применять любые оптимизации, например, считать,
что знаковые целочисленные операции никода не вызывают переполнения.

Игнорирование переполнений при выполнении арифметических операций может приводить к критическим дырам в безопасности системы
(примеры можно найти в презентации выше). Поэтому возникает необходимость проверять результат операций
над целыми числами на возникновение переполнения. Такую проверку можно сделать и средствами языка C, например,
использовать более широкий тип, проверять аргументы и т. п., но все эти способы плохи тем, что проверки
выполняются всегда, даже если результат операции не переполняется, что замедляет все пути выполнения
программы, а не только те, на которых результат вычисления переполняется.

Поэтому некоторые компиляторы предлагают специальные функции для выполнения операций с контролем переполнения. Например,
gcc (начиная с версии 5.0)
предлагает встроенные функции (intrinsic), которые описаны [здесь:](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html)
Эти специальные функции при компиляции программы отображаются в обычные инструкции процессора (например, инструкцию сложения),
после которой добавляется одна дополнительная инструкция проверки на переполнение. Таким образом, вместо одной
машинной инструкции сравнение с переполнением потребует две машинных инструкции. Это в любом случае лучше, чем проверка
на переполнение на уровне языка Си, компиляция которой может потребовать 5 и более инструкций.

Эти специальные функции нестандартны и поддерживаются только компилятором GCC и, возможно, компилятором clang, который пытается
обеспечить совместимость с кодом для GCC. С другой стороны, они доступны везде, где доступен компилятор GCC.
Например, для проверки на переполнение при сложении может использоваться специальная функция `__builtin_add_overflow`.

```
    int value1, value2, result;
    // как-то считываем value1, value2
    if (__builtin_add_overflow(value1, value2, &result)) {
        // в эту ветку попадаем в случае переполнения
        fprintf(stderr, "too bad\n");
    } else {
        // а в эту ветку попадаем при нормальном выполнении
        // в этому случае переменная result содержит результат сложения
    }
```

Естественно, при использовании `__builtin_add_overflow` для сложения знаковых чисел в случае переполнения
не возникнет ситуации Undefined behavior.
