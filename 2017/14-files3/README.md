
# Динамическая загрузка модулей и динамические (разделяемые) объекты

В данном документе рассматривается механизм динамической загрузки модулей, реализованный в Linux.
Linux поддерживает стандарт POSIX для интерфейса библиотеки динамической загрузки и использует формат
исполняемых файлов ELF. Поэтому рассматриваемый код, опции компиляции и имена файлов
будут переносимы на другие POSIX-системы с форматом исполняемых файлов ELF.

Хотя MacOS поддерживает стандарт POSIX, формат исполняемых файлов отличается от ELF. Динамические
библиотеки в MacOS имеют суффикс dylib. Возможно, потребуются немного другие аргументы командной строки
для компилятора и загрузчика.

## Компиляция динамически подгружаемой библиотеки

Чтобы скомпилированный файл можно было бы подгружать в память во время работы программы,
его нужно скомпилировать специальным образом.

Предположим, что в исходном файле myfunc.c определена функция myfunc.

```c
int myfunc(int x)
{
    return x + 1;
}

```

Для компиляции файла в динамически подгружаемую библиотеку нужно выполнить следующие команды:

```
gcc -O2 -Wall -Werror -std=gnu11 -fPIC -DPIC -c myfunc.c
```

отличие от обычной команды компиляции в опциях `-fPIC` `-DPIC`. Опция `-fPIC` включает режим
генерации позиционно-независимого кода. Опция `-DPIC` определяет макрос PIC значением 1.
В исходном коде может использоваться условная компиляция для случая генерации динамически
подгружаемых библиотек, тогда ненулевое значение макроса PIC будет означать генерацию кода для
динамической библиотеки.

Результатом первой команды будет объектный файл `myfunc.o`, который нужно скомпоновать
для получения окончательного результата с помощью команды:

```
gcc -std=gnu11 -fPIC -shared myfunc.o -olibmyfunc.so
```

Опция `-shared` передается в компоновщик (линкер) ld и задает формат выходного файла
shared object (динамически подгружаемая библиотека). Результат компоновки сохраняется 
в файл `libmyfunc.so`.

## Использование динамически подгружаемой библиотеки при компоновке

Предположим, что мы хотим использовать функцию `myfunc` из главной программы.

```
int myfunc(int x);  // определяем прототип функции

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d\n", myfunc(x));
}
```

Объектный файл получается из исходной программы обычной командой компиляции.

```
gcc -O2 -Wall -Werror -std=gnu11 -c main.c
```

Чтобы скомпоновать исполняемую программу с использованием динамически подгружаемой библиотеки
потребуется следующая команда:

```
gcc main.o -L. -Wl,-rpath,. -omain -lmyfunc
```

Опция `-llib` указывает, что поиск всех функций, используемых в главной программе, в том числе функции
`myfunc` должен производиться и в библиотеке `myfunc`, которая находится в файле либо `libmyfunc.so`,
либо `libmyfunc.a` (это статическая библиотека). Динамически подгружаемая библиотека имеет приоритет над
статической библиотекой, кроме случая, когда требуется статическая компоновка (опция `-static`).

Опция `-L.` добавляет текущий каталог (`.`) к списку каталогов, в которых будет искаться файл `libmyfunc.so`.
По умолчанию текущий каталог отсутствует в списке каталогов библиотек, поэтому файл `libmyfunc.so` не будет
найден, несмотря на то, что он находится в текущем каталоге.

Опция `-Wl,` передает опции, записанные непосредственно после запятой, компоновщику, при этом символ запятая
будет разделителем опций. То есть опция `-Wl,-rpath,.` компилятора gcc приведет к тому, что компоновщику
(программе ld) будут переданы помимо всех прочих два аргумента командной строки: `-rpath` и `.`.
Эти аргументы добавляют текущий каталог (.)  в список каталогов, которые будут просматриваться
динамическим загрузчиком (ld-linux.so) для поиска необходимых библиотек при запуске программы.
Как и в случае с каталогами библиотек, текущий каталог отсутствует в списке каталогов,
просматриваемых динамическим загрузчиком по умолчанию, поэтому программа просто не запустится на выполнение.

Другой способ указания текущего каталога для загрузки динамически подгружаемых библиотек - задать
переменную окружения `LD_LIBRARY_PATH` при запуске программы на выполнение:
```
LD_LIBRARY_PATH=. ./main
```
тогда не нужно будет задавать опцию `-Wl,-rpath,.` в командной строке, но потребуется установить переменную
окружения. Вариант с заданием пути поиска динамически подгружаемых библиотек при компиляции программы
предпочтительнее.

В результате компоновки будет получена программа `main`, для выполнения которой потребуется динамически
подгружаемая библиотека `libmyfunc.so`, находящаяся в текущем рабочем каталоге.

FIXME: про ${origin}

## Явная динамическая подгрузка библиотек

В предыдущем примере действия по подгрузке требуемой динамической библиотеки в память процесса,
нахождению в ней имени `myfunc` и связыванию функции из динамической библиотеки с точкой вызова
в основной программе выполняются динамическим загрузчиком (ld-linux.so). Это удобно,
когда имена библиотек и функций известны на этапе компиляции и не меняются динамически.
Как правило, динамическое связывание основной программы и стандартных библиотек используется
по умолчанию.

Однако если имя динамически подгружаемой библиотеки или имя функции в ней неизвестно на этапе
компиляции и определяется на этапе работы программы (берется из конфигурационных файлов
или из ввода пользователя), динамическая компоновка средствами компилятора не применима.
Тогда нужно использовать библиотечные средства для загрузки библиотек и поиска имен в них.

В стандарте POSIX библиотечные функции для динамической загрузки определены в библиотеке dl.
Для их использования необходимо подключить заголовочный файл `dlfcn.h`.

```
#include <dlfcn.h>
```

Функции работы с динамическим загрузчиком не находятся в составе стандартной библиотеки libc, а вынесены
в отдельную библиотеку libdl. Поэтому при компоновке программы необходимо добавить опцию `-ldl`
для подключения этой библиотеки. Командная строка компоновки может выглядеть
следующим образом:

```
gcc main.o -omain -ldl
```

Концептуально при использовании библиотеки libdl каждая подгружаемый динамически модуль рассматривается
как некоторый ресурс, работа с которым ведется по модели "открыть-использовать-закрыть" (аналогично файлам,
каталогам и т. п.).

Динамически подгружаемый модуль загружается в память (т. е. "открывается") с помощью функции 'dlopen'.

```
void *dlopen(const char *filename, int flags);
```

Первый параметр `filename` - это имя файла, содержащего подгружаемый модуль. Если имя файла содержит '/',
оно интерпретируется как абсолютный или относительный путь к загружаемому модулю. Иначе для поиска модуля
используются значение переменной окружения `LD_LIBRARY_PATH`, список путей
вкомпилированный в исполняемый файл с помощью опции `-rpath` и системный список каталогов. Абсолютное имя
файла должно точно указывать на загружаемый модуль. Суффикс имени `.so` (на ELF-системах) можно не указывать, но
можно и указывать.

Параметр `flags` позволяет указать различные флаги. Должен быть указан либо флаг `RTLD_LAZY`, либо флаг `RTLD_NOW`.
`RTLD_LAZY` включает режим отложенного связывания, в котором поиск функции в библиотеке выполняется в момент
первого обращения к ней, а флаг `RTLD_NOW` включает режим немедленного связывания, в котором все действия
по связыванию использования имен с определениями выполняются на этапе загрузки библиотеки. Как правило,
всегда достаточно указать режим `RTLD_LAZY`. Кроме режима открытия в параметре `flags` могут передаваться
дополнительные флаги, объединяемые с помощью операции побитового или (`|`). Описание дополнительных флагов
можно найти в документации на функцию.

В случае ошибки функция `dlopen` возвращает `NULL`,
при этом текстовое сообщение об ошибке можно получить с помощью функции `dlerror`.

В случае успешной загрузки модуля в память процесса функция `dlopen` возвращает "handle" загруженной библиотеки,
некоторый указатель, который нужно передавать в последующие вызовы для работы с данным модулем.
Если модуль уже был загружен в память ранее, будет возвращен ранее созданный "handle", модуль не будет загружаться
второй раз, но счетчик его загрузок будет увеличен на 1. Это означает, в частности, что при повторной загрузке
модуля в память глобальные переменные этого модуля сохранят свои текущие значение, а не будут сброшены в 0.

Информацию об ошибке можно получить с помощью функции `dlerror`.

```
char *dlerror(void);
```

Функция возвращет NULL, если ошибки не было и текстовую строку описания ошибки в противном случае.
При этом флаг ошибки сбрасывается. Таким образом, второй подряд вызов `dlerror` всегда вернет NULL.
По аналогии с `errno` флаг ошибки не сбрасывается при успешном выполнении функций `dlopen`, `dlsym`
и т. п., поэтому перед первым вызовом `dlopen` имеет смысл вызвать `dlerror` чтобы принудительно
сбросить флаг ошибки.

Модуль "закрывается" с помощью функции `dlclose`.

```
int dlclose(void *handle);
```

Если счетчик загрузок модуля становится равным 0, он выгружается из памяти.

Найти в загруженном модуле функцию или переменную можно с помощью функции `dlsym`.

```
void *dlsym(void *handle, const char *symbol);
```

В параметре `handle` передается модуль, в котором нужно искать имя, а в параметре `symbol` - само имя.
Функция возвращает NULL, если имя не найдено, и указатель на соответствующий объект, если имя найдено.
Возвращенный указатель потребуется явно или неявно привести к типу указателя на функцию,
чтобы его можно быть использовать для вызова.

Таким образом, простейший вариант функции `main`, который использует явную
загрузку динамического модуля libmyfunc может быть таким.

```
int main()
{
    int x;
    scanf("%d", &x);
    // подгружаем модуль
    void *handle = dlopen("./libmyfunc.so", RTLD_LAZY);
    // ищем в нем myfunc
    void *sym = dlsym(handle, "myfunc");
    // вызываем
    int res = ((int (*)(int)) sym)(x);
    printf("%d\n", res);
    dlclose(handle);
}
```

В этом примере игнорируются возможные ошибки при выполнении функций `dlopen`, `dlsym`. В реальных программах так делать нельзя!

## Работа с функциями в самой программе

Основная программа принципиально ничем не отличается от подгружаемых модулей, то есть нам может потребоваться искать адреса
функций или переменных по их именам не только в подгружаемых модулях, но и в основной программе. Работа с именами
в основной программе тоже ведется по схеме "открыть-использовать-закрыть". Чтобы "открыть" основную программу
нужно в параметре filename передать NULL, например:

```
    mainhandle = dlopen(NULL, RTLD_LAZY);
```

После чего можно искать имена в основной программе:

```
    mainfunc = dlsym(mainhandle, "main");
```

Однако по умолчанию основная программа компилируется без таблицы имен, доступной для функции `dlsym`,
поэтому функция вернет `NULL`. Чтобы включить генерацию таблицы имен в основную программу
нужно компоновать ее с опцией `-rdynamic`.

```
gcc -rdynamic main.o -omain -ldl
```
