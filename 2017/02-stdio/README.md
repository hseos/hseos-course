# Стандартный ввод-вывод
## Цель семинара
  * Научиться использовать **средства ввода-вывода** стандартной библиотеки языка программирования (ЯП) Си.

Вы уже изучали средства ввода-вывода языка Си++ и, возможно, умеете достаточно хорошо эти средства использовать.
Возможен вопрос: зачем изучать библиотеку языка Си, если уже известна библиотека языка Си++. Библиотека ввода-вывода
языка С++ имеет свои сильные стороны (например, возможность переопределять ввод-вывод для любого пользовательского класса),
но в целом (оценочное суждение) она спроектирована достаточно неудачно.

Стандартная библиотека языка Си нам интересна по следующим причинам:
  * функции стандартной библиотеки Си легко вызвать из других языков (в нашем случае, из программы на ассемблере);
  * стандартная библиотека Си по умолчанию thread-safe (это нам потребуется в дальнейшем);
  * стандартная библиотека Си (иногда существенно) быстрее;
  * форматный ввод-вывод Си, несмотря на особенности, может оказаться удобнее в использовании.

## Ввод-вывод символов
В ходе практических занятий вы будете работать со стандартными потоками ввода-вывода, а именно: ваши программы будут считывать входные данные (условно) с клавиатуры, а выводить результаты (опять-таки, условно) на экран. Мы используем термин "условно", т.к. позже вы узнаете, что источниками и потребителями входной и выходной информации могут выступать разные сущности, но ваша программа никак не догадается, с кем или чем реально она взаимодействует.

Итак, вводя исходные данные с клавиатуры и просматривая полученные результаты на экране, мы имеем дело, в общем случае, с *текстовой* информацией. Такая трактовка оказывается очень простой и универсальной — именно такую модель ввода-вывода поддерживает стандартная библиотека ЯП Си. Текстовый ввод-вывод вне зависимости от того, откуда он исходит или куда направляется, имеет дело с потоком символов. 

**Текстовый поток** — это последовательность символов, разбитая на строки, каждая из которых содержит нуль или более символов и завершается символом новой строки. Обязанность следить за тем, чтобы любой поток ввода-вывода отвечал этой модели, возложена на библиотеку: программист, пользуясь библиотекой, не должен заботиться о том, в каком виде строки представляются вне программы [1].

Текстовый поток, подаваемый на вход вашей программе, может не содержать символа \n в конце последней строки.
Однако, текстовый поток, выводимый вашей программой, обязан содержать символ \n в конце последней строки, в противном случае вы получите "Presentation error".
Исключения: пустой вывод, то есть вывод не содержащий ни одной строки, не должен и содержать \n.
Кроме того, в условии задачи может быть явно оговорено, что финальный \n добавляться не должен, если входной поток его не содержит.
Входной текстовый поток никогда не будет содержать нулевого байта \0.
Выходной текстовый поток никогда не должен содержать нулевого байта, в противном случае вы получите "Presentation error".

Стандартная библиотека включает несколько функций для чтения и записи одного символа. Простейшие из них — `getchar` и `putchar`. За одно обращение к `getchar` считывается следующий символ ввода из текстового потока, и этот символ выдается в качестве результата. Так, после выполнения

```
с = getchar();
```

переменная `c` содержит очередной символ ввода. 

Обращение к `putchar` приводит к печати одного символа. Так,

```
putchar(c);
```

напечатает содержимое целой переменной `c` в виде символа (обычно на экране). Вызовы `putchar` и `printf` (функция форматной печати, речь о которой пойдет ниже) могут произвольным образом перемежаться. Вывод будет формироваться в том же порядке, что и обращения к этим функциям.

### Сигнатуры
По стандарту [2] функции и макросы ввода-вывода символов имеют следующие прототипы:

    #include <stdio.h> 
    
    int	getchar(void);		// equivalent to getc(stdin) 
    int	getc(FILE *);		// possibly MACRO, equivalent to fgetc() 
    int	fgetc(FILE *);	

    int putchar(int);		// equivalent to putc(c,stdout).
    int putc(int, FILE *);	// possibly MACRO, equivalent to fputc()
    int fputc(int, FILE *);

Идентификаторы `stdin` и `stdout`, а также не упомянутый здесь `stderr` имеют тип `FILE*` и обозначают, соответственно, стандартный *входной поток*, стандартный *выходной поток* и стандартный *поток ошибок*. Обычно, стандартный входной поток ассоциирован с клавиатурой, а стандартные выходной поток и поток ошибок — с экраном. Пользователь имеет возможность перенаправлять эти потоки: например, можно настроить выход одной программы на вход другой, при этом сообщения об ошибках (которые обычно выводятся в поток ошибок) будут выводиться на экран.

Как Вам должно быть известно, для работы с символьными данными в ЯП C/C++ одним из основных типов является тип `char` (хотя могут использовать и другие целые типы). Встает вопрос: как отличить при конец ввода от прочих символов, поступающих на вход программе (например, при вызове `getchar`)? Ответ - использовать такое значение, которое не будет совпадать ни с одним значением типа `char`. Это значение есть `EOF` (англ. *end of file* - конец файла) - целая константа, определенная в `<stdio.h>` и имеющая тип `int` (в большинстве реализаций стандартной библиотеки эта константа равна -1, но для переносимости кода следует использовать именно имя `EOF`).

Напоминаем, что является ли тип `char` знаковым или нет - зависит от реализации (implementation defined).
На платформе x86/x64 тип `char` знаковый и, соответственно,
принимает значения в диапазоне [-128;127). На платформе ARM `char` - беззнаковый и принимает значения в диапазоне [0;255].
Кроме того, знаковость типа `char` можно явно задавать при компиляции программы указанием опций `-fsigned-char`, `-funsigned-char`
компилятора GCC. **Ваша программа должна работать корректно при любой знаковости типа `char`.**

Итак, по стандарту [2] семейство функций ввода символа `getchar`, `getc` и `fgetc` считывают очередной один байт из входного потока и в случае успеха именно его возвращают в качестве возвращаемого значения (типа `int`), а в случае невозможности прочитать очередной символ (например, потому что были прочитаны все символы или произошла какая-либо ошибка ввода-вывода) - возвращают `EOF`.

С этим связана одна из стандартных ошибок использования функции getchar(), а именно:
```[c]
char c = getchar();  // НЕПРАВИЛЬНО!
```

Функция `getchar()` возвращает 256 различных значений символов из входного потока **плюс дополнительное специальное значение EOF**.
Эти 257 разных значений никак не могут быть сохранены без потери информации в значении типа char (8 бит). Поэтому произойдет
потеря информации и ваша программа будет либо зацикливаться, либо неправильно обрабатывать некоторые входные файлы. Правильный способ
использования `getchar()` - присвоить результат в переменную с достаточным диапазоном. Обычно это `int`.
```[c]
int c = getchar();   // ПРАВИЛЬНО
```

С другой стороны, семейство функций `putchar`, `putc` и `fputc` рассматривают свой аргумент типа `int` как однобайтный символ (для этого делается конвертация к типу `unsigned char`) и записывают этот символ в выходной поток. В случае успеха возвращают записанное значение, иначе возвращают `EOF` [2].

### Запись символов

Напомним, что в тексте программы символьные константы записываются с использованием одиночных кавычек: например, буквы `'a'`, `'Y'`, цифра `'0'` (не путать со значением константы `0`) или символ `'@'`.

Для написания специальных символов используются так называемые *escape-последовательности* (или *экранирование* символов). При их написании используется символ обратной косой черты (backslash), например:

 * `'\n'` - символ перевода новой строки,
 * `'\r'` - символ возврата каретки,
 * `'\t'` - символ табуляции,
 * `'\b'` - символ забоя (backspace), 
 * `'\\'` - собственно, символ обратной косой черты,
 * `'\''` - одинарная кавычка (апостроф),
 * `'\"'` - двойная кавычка.

## Построчный ввод-вывод

Библиотечная функция `fgets` позволяют вводить последовательность символов из входного потока до достижения символа конца строки \n
или до конца файла (что наступит раньше). Функция заполняет буфер фиксированного размера, параметры которого передаются этой функции.
Сейчас мы только упомянем эту функцию, а более подробное рассмотрение отложим до рассмотрения темы строк.

## Форматированный ввод-вывод

Несколько библиотечных функций позволяют преобразовывать значения между внутренним представлением и текстовыми последовательностями, которые могут быть прочитаны и записаны [3]. Функции делятся на две группы:

 * Функции печати, объявленные в заголовочном файле `<stdio.h>`, преобразуют внутреннее представление в последовательности типа `char` и позволяют комбинировать последовательности для вывода. К этой группе относятся, например, функции `fprintf`, `printf`, `sprintf`, `snprintf`.
 * Функции сканирования, объявленные в `<stdio.h>`, преобразуют последовательности типа `char` и позволяют сканировать считываемые последовательности. К этой группе относятся функции `fscanf`, `scanf`, `sscanf`.
 
Одним из традиционно приписываемых недостатков форматного ввода-вывода Си является его **типонебезопасность**, то есть вы можете передать
аргументы для ввода-вывода, не соотвествующие по количеству или по типам переданной форматной строке.
Однако, все современные компиляторы языка Си умеют распознавать использование функций форматного ввода-вывода, анализировать строку формата
и проверять ее соответствие фактически переденным параметрам. Для включения проверки форматного ввода-вывода в компиляторе GCC используется
опция `-Wformat`, которая активируется при указании опции `-Wall`. Поэтому еще раз напоминаем, что программы на языке Си **должны**
компилироваться вами с опциями `-Wall -Werror`.

### Задание форматирования

У любой из указанных функций в списке формальных аргументов имеется аргумент `format`, являющийся строкой формата, которая определяет требуемые преобразования. Строка формата состоит из нуля или более спецификаций преобразования, литерального текста и пробельных символов (например, символов табуляции или перевода новой строки).

**NB** Суффикс *f* в наименовании указанных функций говорит именно о том, что пользователь может задавать форматирование.

Для задания форматирования используют символ процента и следующий за ним спецификатор (например, `%d` для работы с целыми числами, `%g` - для вещественных чисел одинарной точности `float`, `%lg` - для вещественных чисел двойной точности `double`). Полный список можно найти, например, в [3]: см. Таблицы 1-2 описания спецификаторов форматного вывода и Таблицу 3 со спецификаторами форматного ввода.  


### Форматированный вывод

По стандарту [4] функции вывода имеют следующие прототипы:

	#include <stdio.h>
	
	int printf(const char *format, ...); 
	int fprintf(FILE *stream, const char *format, ...);	
	int snprintf(char *s, size_t n, const char *format, ...);
	int sprintf(char *s, const char *format, ...);

Функция `printf` осуществляет вывод результата в стандартный выходной поток (ассоциированный с `stdout`), функция `fprintf` - в указанный поток `stream`, а функции `sprintf` и `snprintf` - в буфер `s` (более подробно эти функции будут рассматриваться на другом занятии, посвященном работе со строками).

Функции возвращают в случае успеха число записанных байт либо отрицательное значение в случае ошибки.

Примеры использования функции printf:
```
    printf("Hello, world\n"); // выводим строку как есть
    printf("The answer is: %d!\n", 42); // выводим строку The answer is: 42! и перевод строки
    printf("One says: %d%% of 100 is %d\n", 6, 13); // вывод: One says: 6% of 100 is 13
    printf("%x", 256); // вывод: 100
    printf("%08x", 512); // вывод: 00000200
    printf("%llu", -1LL); // вывод: 18446744073709551615
    printf("%f", 3.1415926535897932384626433832795028841971); // вывод: 3.141593
    printf("%.10g\n", 3.141592653589793238 * 100000000000.0); // вывод: 3.141592654e+11
```

Хотя чаще всего в качестве форматного аргумента функций форматного вывода передаются константные строки, вполне допустимо передавать и произвольные
строки, даже сформированные во время работы программы. В этом случае компилятор не может проверить соответствие формата фактическим параметрам и
вы используете функции форматного вывода на свой страх и риск. **Неправильное использование переменного форматного параметра может
приводить к уязвимостям в программе вплоть до того, что заданием специально подготовленной строки пользователь вашей программы
может заставить ее выполнить произвольный код.**

### Форматированный ввод

По стандарту [5] функции ввода имеют следующие прототипы:

	#include <stdio.h>
	
	int scanf(const char *format, ... );
	int fscanf(FILE *stream, const char *format, ... );	
	int sscanf(const char *s, const char *format, ... );

Функция `scanf` осуществляет ввод данных из стандартного выходного потока (ассоциированного с `stdin`), функция `fscanf` - из указанного потока `stream`, а функция `sscanf` - из буфера `s` (более подробно эти функция будет рассматриваться на другом занятии, посвященном работе со строками). Каждая функция считывает байты, интерпретирует их согласно заданному формату `format` и сохраняет полученные результаты в своих аргументах. Таким образом, ожидается, что в качестве аргументов пользователь задает список адресов (т.е. указателей), по которым будут сохраняться считанные значения. Несоответствие какого-либо аргумента форматной строке `format` приводит к неопределенному поведению. 

Большинство форматных преобразований чтения, например, %d, %f, %s перед выполнением чтения пропускают пробельные символы.
Поэтому о пропуске пробельных символов отдельно заботиться не нужно. Исключение - %c.

В случае успеха функции возвращают число обработанных аргументов (успешно считанных, разобранных и сохраненных), или ноль, если был неуспешным разбор самого первого аргумента. В остальных случаях (окончание данных во входном потоке или ошибка разбора очередного аргумента) возвращается `EOF`, возможно с побочными эффектами [5].

Примеры использования функции `scanf`:
```
    // в цикле считываем последовательность целых чисел разделенных пробельными символами до признака конца файла
    int a;
    while (scanf("%d", &a) == 1) {
    }

    // в цикле считываем последовательность пар целых чисел до признака конца файла
    int a, b;
    while (scanf("%d%d", &a, &b) == 2) {
    }

    // считываем long long
    long long x;
    scanf("%lld", &x);

    // считываем double
    double d;
    scanf("%lf", &d);
    // обратите внимание, что double выводится в printf с помощью %f, а считывается с помощью %lf

    // считываем пару шестнадцатеричных чисел, разделенных минусом, например, 100-1ff
    unsigned l, h;
    scanf("%x-%x", &l, &h); // для примера выше получим результат l == 0x100, h == 0x1ff
```

## Файловый ввод-вывод

По стандарту [6-7] функции открытия и закрытия файлов имеют следующие прототипы:

	#include <stdio.h>
	
	FILE *fopen(const char *filename, const char *mode);
	int fclose(FILE *stream);

Функция `fopen` открывает файл с именем, указанным в первом аргументе, и связывает с этим файлом поток. В качестве `mode` пользователь может задать режим открытия файла (обязательно один из вариантов):

* `r` - открытие файла на чтение.
* `w` - открытие файла на запись, при этом если файл существовал, то содержимое его удаляется (т.е. обнуляется длина файла), если же файл не существовал, то он создается.
* `a` - открытие файла на запись в конец; если файл не существовал, он создается.
* `r+` - открытие на чтение и запись.
* `w+` - открытие на чтение и запись с обнулением длины существующего файла или созданием нового файла.
* `a+` - открытие на чтение и запись в конец файла, если файл не существовал, он создается.

Дополнительно может задаваться символ `b` в строке `mode` (например, `"rb"`), означающий, что открывается бинарный файл (этот флаг не играет роли в *nix-системах, но имеет значение при работе в Windows-системах).

В случае успеха, функция `fopen` возвращает указатель на поток (дескриптор потока) типа `FILE*`, который можно использовать, например, в функциях `fprintf` или `fscanf`. В случае ошибки функция возвращает нулевой указатель.

Функция `fclose` получает на вход дескриптор потока (полученный, например, ранее с помощью вызова `fopen`), производит освобождение буферов и закрытие ассоциированного файла. В случае успеха возвращает `0`, в случае ошибки - `EOF`.

## Буферизация

### Буферизация вывода

Следующий код ничего не выведет на экран до тех пор, пока программа не будет завершена через 10 секунд своей работы:

```
#include <stdio.h>
#include <unistd.h>

int main()
{
    for (int i=0; i<10; ++i) printf("%d",i);
    sleep(10);
    return 0;
}
```

Причина такого поведения заключается в *буферизации* вывода: все выводимые символы предварительно сохраняются в буфере вывода, и выводятся на терминал в одном из случаев:
 1. Буфер переполнен (как правило, его размер не менее 4 килобайт)
 2. Работа программы завершилась
 3. Вывод в поток содержит символ перевода строки `'\n'`
 4. Вызвана функция чтения с терминала, например, `scanf`
 5. Буфер принудительно сброшен с помощью функции `fflush`.

Такой режим буферизации называется *построчная буферизация*.

Единственный аргумент функции `fflush` - это указатель на поток типа `FILE*`, либо нулевой указатель, если требуется принудительный сброс всех буферов.

Однако, если стандартный поток вывода перенаправлен в файл или в канал, или данные выводятся в файл, открытый `fopen`, запись
в файл выполняется в режиме *полной буферизации*: все выводимые символы предварительно сохраняются в буфере вывода,
и выводятся на терминал в одном из случаев:
 1. Буфер переполнен (как правило, его размер не менее 4 килобайт)
 2. Работа программы завершилась
 3. Буфер принудительно сброшен с помощью функции `fflush`.

Символ \n теряет свое специальное значение.

Принципиальное отличие стандартного потока `stderr` от `stdout` заключается в отсутствии буферизации.

### Буферизация ввода

Чтение из файлового потока также выполняется с буферизацией, например,
```
    int c;
    while ((c = getchar()) != EOF) {
    }
```
функция `getchar()` пытается считать со стандартного потока ввода сразу блок данных размером буфера ввода.
Затем функция `getchar()` будет возвращать по одному символу из считанного буфера.

Функция `fflush` применима к некоторым входным потокам. Она пытается вернуть пока непрочитанную часть
входного буфера обратно в файл. Эта операция применима только к файлам, называемым *файлами произвольного доступа*
(речь о которых пойдет позже в курсе). Ни к терминалам, ни к каналам эта функция неприменима. Поэтому в дальнейшем эта функция
использоваться не будет, более того, её применение ко входным потокам будет считаться ошибой стиля кодирования.

### Управление буферизацией

Для управления буферизацией при выводе в учебных программах нам будет достаточно использования функции `fflush` в
нужных местах. Однако, существуют функции, позволяющие настраивать буферизацию файловых потоков.
Вы можете прочитать описания функций `setbuf`, `setbuffer`, `setlinebuf`, `setvbuf` самостоятельно.

## Потокобезопасность

Как было упомянуто выше, функции ввода-вывода языка Си являются потокобезопасными (thread-safe).
Это значит, что их можно использовать одновременно в нескольких потоках (или еще говорят нитях - threads),
что нам потребуется в дальнейшем. Однако потокобезопасность имеет свою цену. При входе в каждую
функцию и при выходе из каждой функции требуется выполнять дополнительные действия для
обеспечения безопасной работы (как мы узнаем позже - захватывать и освобождать мьютех).

В однопоточных программах, то есть в программах, которые не создают дополнительных потоков выполнения
после своего запуска, такие дополнительные действия только понижают производительность ввода-вывода.

Поэтому стандартная библиотека Си содержит функции ввода-вывода, аналогичные обычным функцяим ввода-вывода,
но которые не удовлетворяют свойству потокобезопасности. Такие функции содержат `_unlocked` в своем имени.
Например, функции `getchar()` соответствует функция `getchar_unlocked()`, `putchar()` - `putchar_unlocked()`
и т. д. Скорость таких функций может превосходить скорость потокобезопасных функций в несколько раз,
и она практически равна скорости низкоуровневого чтения из файла. Другими словами, вы вряд ли сможете считывать
данные из файла быстрее, чем это делает функция `getchar_unlocked()`.

## Библиография
1. Керниган Б.В., Ритчи Д.М. Язык программирования C, 2-е издание. — М. : Издательский дом "Вильямс", 2007.
2. <stdio.h>. The Open Group Base Specifications Issue 6 [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2004. — Режим доступа: [http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html).
3. А.В. Чернов. Функции форматного ввода-вывода. [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2013. — Режим доступа: [https://ejudge.ru/study/3sem/formatio.pdf](https://ejudge.ru/study/3sem/formatio.pdf).
4. fprintf. The Open Group Base Specifications Issue 6 [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2004. — Режим доступа: [http://pubs.opengroup.org/onlinepubs/009695399/functions/printf.html](http://pubs.opengroup.org/onlinepubs/009695399/functions/printf.html).
5. fscanf. The Open Group Base Specifications Issue 6 [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2004. — Режим доступа: [http://pubs.opengroup.org/onlinepubs/009695399/functions/scanf.html](http://pubs.opengroup.org/onlinepubs/009695399/functions/scanf.html).
6. fopen. The Open Group Base Specifications Issue 6 [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2004. — Режим доступа: [http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html](http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html).
7. fclose. The Open Group Base Specifications Issue 6 [Электронный ресурс]. — Электрон. дан. — [Б. м.] : 2004. — Режим доступа: [http://pubs.opengroup.org/onlinepubs/009695399/functions/fclose.html](http://pubs.opengroup.org/onlinepubs/009695399/functions/fclose.html).
