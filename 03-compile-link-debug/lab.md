## Цель семинара
  * Понять: общую схему трансляции и запуска программ в операционной системе.
  * Научиться: компиляции и сборке программ на C++, состоящих из одного или нескольких файлов; отладке программ в среде Linux.

## Содержание семинара
  1. Исполняемый файл, запуск исполняемого файла операционной системой.
  2. Компиляция .cpp -> .o. Флаги компиляции.
  3. Препроцессор, заголовочные файлы, директива #include.
  4. Компоновка (линковка) исполняемого файла. Использование динамических и статических библиотек.
  5. Отладка программы с помощью gdb. Точки останова (breakpoints). Способы запуска отладчика.
  6. ~~Гадание~~ Отладка по coredump.

## Теоретическая справка

Процесс компиляции C/C++ можно разбить на 3 фазы: препроцессинг, трансляция и связывание объектного кода.

### Препроцессинг

На этой фазе обрабатываются *директивы препроцессора* - строки файла, начинающиеся с символа `#`. Две основные директивы:
  * `#include "file.h"` - заменяется на содержимое файла `file.h`. Важно понимать, что `#include` всего лишь подставляет
  один файл в другой. Например, если подключить один и тот же файл 2 раза, это скорее всего приведёт к ошибкам компиляции.
  Для решения этой проблемы применяются include guards или деректива `#pragma once`.
  * `#define FOO bar` - заменяет все встречи строки символов `FOO` в файле, на строку `bar`.

**Пример 1:**

  math.h
  ```
  #define PI 3.1415

  double sin(double x);
  ```
  math.cpp
  ```
  #include "math.h"

  double cos(double x) {
      return sin(x + PI / 2);
  }
  ```
  math.cpp после обработки препроцессором
  ```
  double sin(double x);

  double cos(double x) {
      return sin(x + 3.1415);
  }
  ```

  **Важно**: использование `#define`-ов (макросов) в C++ является признаком плохого кода, так как макросы ухудшают читаемость кода. Для объявления глобальных констант лучше использовать конструкцию 
  
  ```static const ТИП ИМЯ = ЗНАЧЕНИЕ;```
  
  Это не только сделает код более понятным, но и даст компилятору возможность проверки ошибок, связанных с типизацией. Макросы `#define`, как правило, используются в двух случаях:
  
* Жесткая экономия памяти программ. Обычно, - при разработке программ для 8-битных микроконтроллеров, где ценится каждый байт. Использование макроса `#define`, в отличии от создания отдельной переменной, не приводит к затратам памяти на хранение этой переменной.
* Объявление значений для условной компиляции, в зависимости от целевой операционной системы, архитектуры или определенной конфигурации программы.


**Пример 2:**

config.h (как правило, сгенерированный файл)
```
#pragma once
#ifndef CONFIG_H
#define CONFIG_H

#define CONFIG_PLATFORM_WIN32
#define CONFIG_USE_EXTERNAL_LIB_VERSION 4

#endif  // CONFIG_H
```

usage.cpp
```
#include "config.h"
#include <some_external_great_library.h>
#include <iostream>

#ifdef CONFIG_PLATFORM_WIN32
    static const char PATH_SEPARATOR = '\\';
#else
    static const char PATH_SEPARATOR = '/';
#endif

void foo()
{
#if CONFIG_USE_EXTERNAL_LIB_VERSION >= 5
    ExternalLib::functionDeclaredSinceVersion5();
#else 
    ExternalLib::alternateFunctionDeclaredInOldVersion();
#endif

// значение NO_DEBUG может быть определено не в config.h,
// а передачей параметра в качестве опции компилятора
#ifndef NO_DEBUG
    std::cerr << "foo() executed" << std::endl;
#endif
}
```
  
  **Замечание**. Использование директивы `#pragma once` позволяет ускорить процесс компиляции, по сравнению с header guard.
  Тем не менее, необходимо всегда добавлять header guards в заголовочные файлы после `#pragma once`, - это необходимо для компиляторов, которые их не поддерживают данную директиву.
  
  
  **Пример 3:**
  
  base_module.h
  ```
  #pragma once
  #ifndef BASE_MODULE_H
  #define BASE_MODULE_H
  
  class Base {};
  
  #endif  // BASE_MODULE_H
  
  ```
  
  derived_module.h
  ```
  #pragma once
  #ifndef DERIVED_MODULE_H
  #define DERIVED_MODULE_H
  
  #include "base_module.h"
  
  class Derived: public Base {};
  
  #endif  // DERIVED_MODULE_H
  ```
  
  main.cpp
  ```
  #include "base_module.h"     // Загружено описание Base
  #include "derived_module.h"  // Загружено описание Derived, но не Base
  
  ```
  
  В данном примере, если препроцессор поддерживает `#pragma once`, то при обработке строки `#include "base_module.h"`
  он включает целиком содержимое файла `base_module.h` и запоминает, что этот файл уже был включен.
  
  При обработке строки `#include "derived_module.h"`, препроцессор включает и обрабатывает содержимое файла `derived_module.h`,
  где встречает строку `#include "base_module.h"`, но это строку он уже не обрабатывает, поскольку файл `base_module.h` уже 
  был включен ранее.
  
  Если препроцессор не поддерживает прагму `once` (она не является частью стандарта C++), то препроцессинг происходит немного
  по-другому. При обработке строки `#include "base_module.h"` в файле `main.cpp`, препроцессор включает и обрабатывает содержимое файла `base_module.h`. Строку `#pragma once` препроцессор игнорирует, возможно, выдав предупреждение о неизвестной
  прагме. В процессе его обработки, создается пустое макроопределение `BASE_MODULE_H`. При включении
  и обработке файла `derived_module.h`, когда компилятор встречает строку `#include "base_module.h"`, то он читает и обрабатывает файл "base_module.h", даже несмотря на то, что он уже был ранее включен. 
  В процессе повторной обработки этого файла, когда препроцессор встречает строку `#ifndef BASE_MODULE_H`, то он находит пустое, ранее созданное макроопределение `BASE_MODULE_H`, и поэтому пропускает все строки до `#endif` (или `#else`).
  


### Компиляция (трансляция)

На этой фазе, выход препроцессора преобразуется в машинный код. Результатом компиляции являются
  *объектные файлы*.

  Чтобы скомпилировать C++ файл, нужно выполнить команду `g++ my_file.cpp -c -o my_file.o`.
  * `-o my_file.o` - результат компиляции нужно записать в файл `my_file.o`.
  * `-c` - только компилировать. Без этой опции gcc попытается сразу сделать исполняемый файл.
  * `-S` - только компилировать, результат сохранить в виде текстового файла, содержащего ассемблерный код. Эта опция бывает полезна для изучения результата компиляции.
  * `-E` - выполнить только препроцессинг.

  Компилятору можно передавать дополнительные флаги, например:
  * `-Wall` - печатать предупреждения, об опасных конструкциях в коде.
  * `-Werror` - считать ошибками все предупреждения об опасных конструкциях в коде. Качественный код должен обязательно компилироваться с этой опцией.
  * `-O2` - включить оптимизации. По умолчанию код собирается без оптимизаций. Код, собраный с оптимизациями работает значительно быстрее. Другие возможные опции: `-O0` - отключить оптимизации, `-O1` - слабая оптимизация, `-O3` - агрессивная оптимизация, `-Os` - оптимизация размера кода, возможно, в ущерб производительности.
  * `-fPIC` - собрать Positional Independent Code. Необходимо для сборки shared библиотек.
  * `-std=c++11` - включить стандарт C++11. Можно явно указывать стандарты `c++98`, `c++03`, `c++11`, а для свежих версий компиляторов - `c++14`.
  * `-g` - добавляет в выходной файл отладочную информацию.
  * `-Ipath` - добавляет путь `path` в список путей поиска заголовочных файлов.
  * `-DИМЯ` - имитирует директиву препроцессора `#define ИМЯ`.
  * `-DИМЯ=ЗНАЧЕНИЕ` - имитирует директиву препроцессора `#define ИМЯ=ЗНАЧЕНИЕ`.
  

Чтобы скомпилировать Cи-файл (начиная со стандарта C99, этот язык уже заметно отличается от C++), вместо команды `g++` нужно использовать команду `gcc`. В данном случае можно указывать одну из опций, определяющий стандарт языка Си: `-ansi`, `-std=c99`, или `-std=c11`.

**Замечание.** Набор компиляторов GCC определяет исходный язык программы, руководствуясь именем входного файла:
 * `*.c` - файл на языке Си
 * `*.C`, `*.cc`, `*.cxx`, `*.cpp` - файл на языке C++
 * `*.m` - файл на языке Objective-C
 * `*.M`, `*.mm` - файл на языке Objective-C++.
 
Тем не менее, лучше не полагаться на эту особенность компилятора, и указывать явно правильные команды, вызывающие компилятор: `gcc` для языка Си и `g++` для языка C++.

Помимо команд `gcc` и `g++`, в UNIX-подобных системах можно использовать команды `cc` и `c++`, которые вызывают настроенные по умолчанию компиляторы Си или Си++. С системе Linux, как правило, эти команды являются символическими ссылками на `gcc` и `g++`. Помимо набора компиляторов GCC также часто используются компиляторы CLang (команды `clang` и `clang++`) и Intel (команды `icc` и `icpc`). Набор опций у этих компиляторов совместим с набором опций GCC, который мы будем использовать в рамках данного курса.


### Связывание (линковка)

На этом этапе объектные файлы объединяются в исполняемый файл или shared библиотеку.

Линковка выполняется с помощью команды `ld`, которой указываются входные объектные файлы и все используемые библиотеки, включая базовые. По этой причине, использовать команду `ld` не удобно, и обычно для линковки используется одна из команд: `gcc` или `g++`, которые, в свою очередь, вызывают `ld` с указанием нужных параметров.

  Чтобы получить исполняемый файл из нескольких объектных файлов, нужно выполнить команду
  `gcc my_file.o other_file.o -o myprog`

  Затем его можно запустить:
  `./myprog`
  
  **Замечание.** В данном примере подразумевается, что `my_file.o` и `other_file.o` являются продуктом компиляции Си-файлов. Если *хотя бы один* из объектных модулей реалован на С++, то эта команда завершится с ошибкой, поскольку линковщик будет использовать только Си-библиотеку и не найдет реализацию функций, специфичных для C++. В этом случае нужно использовать команду `g++`:
  `g++ my_file.o other_file.o -o myprog`
  

  <!---
  *NOTE* Символ `./` означает путь относительно текущего каталога в консоли. По умолчанию
  система ищет исполняемый файл в каталогах `/usr/bin` и `/usr/local/bin`. Для запуска файлов из
  других каталогов необходимо либо набирать полный путь вида `/home/vasya/myprog`, либо указывать
  путь относительно текущего каталога.
  -->

  Чтобы выполнить линковку с библиотекой, нужно указать ключ `-lmylib`, где `mylib` --- имя
  библиотеки, с которой нужно выполнить линковку. При этом библиотека должна находиться в списке
  путей поиска библиотек (определяется переменной окружения `LD_LIBRARY_PATH`), либо путь к библиотеке 
  может быть явно указан с помощью опции `-Lдополнительный_путь_к_библиотекам`.


<!---
**TODO:** картинка про стадии компиляции.
-->


Для отладки исполняемых файлов существуют отладчики. В среде Linux есть стандартный консольный отладчик gdb. Управление отладчиком происходит через командный интерфейс (список самых частых команд приведен ниже).
Отладчик gdb можно использовать в трех режимах:

1. Запускать в нем исполняемый файл

 `gdb ./myprog`

 После того, как отладчик загрузил исполняемый файл и готов к работе, можно запустить исполняемый
 файл.
 В командной строке gdb наберите

 `> run`

3. Отладка при помощи [дампа
   памяти](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BC%D0%BF_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8) процесса (coredump).

 Как правило, дамп памяти сохраняется, когда процесс завершается из-за критической ошибки (например,
 ошибки сегментации). В этом случае, проанализировав дамп памяти, иногда можно понять, что послужило
 ошибкой.

 `gdb myprog /path/to/core`

 По умолчанию Linux сохраняет дампы памяти в директорию `/proc/sys/kernel/core_pattern`.

 <!---
 TODO: проверить core_pattern
 -->


 Чтобы система сохраняла дамп памяти в случае завершения процесса из-за критической ошибки, нужно
 выполнить

 `ulimit -c unlimited`


2. Присоединяться к запущенному процессу

 Если процесс запущен и работает (например, это системный демон или web-сервер),
 то можно при помощи отладчика, например, посмотреть на его состояние,
 поставить точку останова в определенной функции.

 Для этого необходимо узнать идентификатор процесса PID, к которому мы хотим подключиться, а затем
 выполнить

 `gdb --pid PID`

 Либо можно запустить `gdb`, а в его командной строке выполнить

 `gdb attach PID`

 Команду `run` при этом выполнять не нужно.

 Для отладки запущенного процесса необходимо обладать правами не ниже, чем права запущенного процесса.

 Часто используемые команды отладчика gdb (указан длинный и короткий варианты команды, использовать
 можно любой):
 * `backtrace`, `bt` -- просмотреть стек вызовов;
 * `print x`, `p x` -- просмотреть значение переменной `x`;
 * `display x` -- отображать значение выражения `x` каждый раз при остановке программы;
 * `break`, `b` -- поставить точку останова (breakpoint). Дойдя до этой точки, выполнение процесса
  прервется, вы снова получите доступ в командную строку `gdb`;
 * `next`, `n` -- перейти к следующей строке программы;
 * `list`, `l` -- просмотреть исходный код текущей строки программы и 50 строк после нее;
 * `continue`, `c` -- продолжить выполнение;
 * `step`, `s` -- перейти внутрь функции, находящейся на текущей строке;
 * `finish` -- вернуться на уровень выше (выйти из функции);
 * `help`, `h` -- показать справку, из которой можно узнать другие полезные команды.

## Задание

0. Склонируйте репозиторий http://github.com/hseos/sem-03.git.

1. В файле `bc.cpp` реализован калькулятор арифметических выражений. Он представляет из себя простой REPL.
  Сначала по входной строке строится дерево разбора (функция `Parse()`), затем это дерево вычислется (фукция `Eval()`).
  В файле `ast.h` находятся определения структур, из которых состоит дерево разбора (**не путать с деревом поиска!**).

  Скомпилируйте файл `bc.cpp` и запустите получившийся исполняемый файл. Вычислите значение выражения 1 + 2 * 3.

  *Note: В калькуляторе используется класс `std::unique_ptr`, появивившийся в стандарте c++11. Чтобы файл скомпилировался,
  нужно указать компилятору опцию `-std=c++11`.*

  *Note: Для выхода из калькулятора используйте сочетание клавиш Ctrl+C.*

2. Логику работы необходимо отделить от обработки входных данных и вывода результата и выделить в отдельный файл.
  Поместите функции `Parse()` и `Eval()` в файл `calc.cpp` и прототипы этих функций в `calc.h`. Скомпилируёте файлы `calc.cpp` и `bc.cpp` в
  один исполняемый файл. Убедитесь, что калькулятор запускается.

3. В файле `calc_test.cpp` находятся юнит-тесты. Тесты используют библиотеку gtest.
  Скомпилируйте файлы `calc_test.cpp` и `calc.cpp` вместе с библиотекой `gtest/libgtest.a` в один исполняемый файл. Запустите тесты,
  убедитесь что они проходят.

  *Note: Библиотека gtest использует системную библиотеку pthread. Чтобы подключить её, нужно добавить флаг -lpthread.*

4. Запустите исполняемый файл и вычислите значение выражения 42 / 0. Что произошло с программой?
  Запустите программу под отладчиком и снова вычислите значение выражения 42 / 0. Можете ли Вы найти строку программы, в которой происходит ошибка?

  Пересоберите калькулятор с отладочной информацией, снова запустите программу под отладчиком. Найдите строчку в программе, на которой происходит ошибка.

  Измените программу так, чтобы вместо деления на ноль она бросала исключение. Добавьте тест, проверяющий что программа больше не падает.

5. Что делать, если программа падает, но у вас нет входных данных, на которых это происходит?
  Включите запись coredump. Затем запустите скрипт compute.sh.
  Запустите отладчик на получившимся core файле. Найдите строчку в программе, на которой произошла ошибка.
  Исправьте ошибку. Добавьте тест, проверяющий что ошибка исправлена.

<!---
**TODO:** инструкция по сдаче лабы на автоматическую проверку.
-->

## Дополнительное задание
Линковка может происходить не только на этапе компиляции, но и в момент запуска программы. Этот случай называют *динамической* линковкой.
Вы уже видели, как можно указать, что к программе нужно прилинковать динамическую библиотеку (флаг -lpthread). При встрече этого флага, компилятор
вставляет в исполняемый файл информацию, которая используется динамическим линковщиком. Эту информацию можно посмотреть в любой момент, с помощью
команды ldd (посмотрите, какие динамические библиотеки использует python).

Существует возможность в момент запуска прилинковать динамическую библиотеку, даже если её не указывали в момент компиляции. Для этого используется
переменная окружения `LD_PRELOAD`. Например: `LD_PRELOAD=libmyoverrides.so ./bc`. При этом, если в динамической библиотеке будут объявлены какие-то
функции, которые уже есть в исполняемом файле, будут использованы реализации функций из динамической библиотеки. Это позволяет менять поведение
уже скомпилированных программ.

Запустите файл `my_login`. Для своей работы он просит пароль. Вам не известно, по какому алгоритму определяется валиндость пароля, зато известно,
что этой проверкой занимается функция с сигнатурой `bool is_password_valid(char* passwd);`. Напишите реализацию функции, которая считать любой пароль
правильным. Скомпилируйте файл с этой функцией в динамическую библиотеку. Загрузите библиотеку с помощью `LD_PRELOAD` и добейтесь того, чтобы программа
приняла пароль.

<!--
**TODO** Бинарник для доп задания
-->

## Вопросы

1. Напишите команду, которая скомпилирует файлы `a.cpp`, `a.h` и `b.cpp` в один исполняемый файл.
2. Почему нельзя скомпилировать файлы bc.cpp calc.cpp и bc_test.cpp в один исполняемый файл?
3. Можно ли линковать вместе объектные файлы, собранные с разными уровнями оптимизации?
4. Почему нельзя писать тело функции в заголовочном файле?
5. В чем преимущество отладки по coredump-у перед отладкой работающего процесса? В чем состоят недостатки?
6. Можно ли include-ить .cpp файлы?
7. Должен ли .h файл содержать синтаксически корректную программу?
