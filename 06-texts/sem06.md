Динамическое выделение памяти
=============================

Выделение и освобождение памяти в Си:

* `void* malloc(size_t n_bytes)` - выделяет память для
 хранения `n_bytes` байт, возвращает нетипизированный
 указатель на выделенную область

* `void free(void *pointer)` - освобождает память,
выделенную ранее функцией `malloc`


Выделение и освобождение памяти в Си++:

* оператор `T* new T(...)` - выделяет память для хранения
для хранения объекта типа `T` и инициализирует его

* оператор `delete pointer` - освобождает память,
выделенную ранее оператором `new`

* оператор `T* new T[n_items]` - выделяет память для
хранения `n_items` экземпляров объекта типа `T` и
инициализирует их

* оператор `delete[] pointer` - освобождает память,
выделенную ранее оператором `new[]`

Рекомендуется всегда использовать `new`/`delete` вместо
`malloc`/`free`, поскольку:
1. Вызываются конструкторы классов
2. Не требуется явным образом выполнять приведение
типа указателя от `void*`


Массивы
=======

Массив в Си/Си++ - это **непрерывная** область памяти.
Доступ к элементу массива осуществляется через *указатель*.

Пример:

```c++
char* array_of_chars = new char[3];

* array_of_chars      = '0';
*(array_of_chars + 1) = '1';
*(array_of_chars + 2) = '2';

```

К переменным типа *указатель* можно применять операции
сложения `+` и вычитания `-` c целыми числами. При этом
значение указателя изменяется на `n=i*sizeof(T)` байт,
где `i` - значение целого числа, `sizeof(T)` - размер
элемента **в байтах**.

Пример:

```c++
int32_t* array_of_ints = new int32_t[3];

int32_t*  first_ptr = array_of_ints;
int32_t* second_ptr = array_of_ints + 1;
int32_t*  third_ptr = array_of_ints + 2;

assert( 4 == uintptr_t(second_ptr) - uintptr_t(first_ptr) );
assert( 8 == uintptr_t( third_ptr) - uintptr_t(first_ptr) );
```

Эквивалентом записи `*(pointer + offset)` является запись
`pointer[offset]`. При этом, `&(pointer[0]) == pointer`.


Приведение типов указателей
===========================

Явное приведение типа в Си-стиле (через скобки) указателей
означает, что содержимое памяти, на которое ссылается
указатель, будет интерпретировано по-другому.


```c++
float    f = 1.05;
int32_t  i = (int32_t) f; // i = 1; отброшена дробная часть

float*   f_ptr = &f;
int32_t* i_ptr = (int32_t*) f_ptr;
i = *i_ptr; // i = 1065772646
```

В приведенном примере во втором случае значение переменной
`f` равно `1.05`, что представляется как
`1 11111100 001100110011001100110` в формате IEEE754.
Указатель `f_ptr` ссылается на это значение, и этот адрес
присваивается указателю `i_ptr`. Операция `*` (раскрытие
указателя) читает значение по указанному адресу, при этом
значение интерпретируется как `int32_t`, в соответствии
с объявлением типа указателя `i_ptr`.

Аналогичным оператором в языке C++ является `reinterpret_cast`.


```c++
float    f = 1.05;
int32_t  i = static_cast<int32_t>(f);
// i = 1; отброшена дробная часть

float*   f_ptr = &f;

// В этой строке будет ошибка компиляции...
int32_t* i_ptr = static_cast<int32_t*>(f_ptr);

// ...правильно - использовать reinterpret_cast
int32_t* i_ptr = reinterpret_cast<int32_t*>(f_ptr);

i = *i_ptr; // i = 1065772646
```

Операторы приведения типов в C++
================================

* `static_cast<T>(value)` - выполяет семантическое приведение типа
к `T` значения `value`. При этом, на **этапе компиляции**
выполняется проверка возможности приведения типа. В случае,
если это невозможно, возникает ошибка компиляции.

* `static_cast<Class*>(pointer)` - выполняет приведение типа
указателя `pointer` к указателю на `Class`. Обычно используется
для приведения типа от базового класса к наследуемому.
Проверка возможности приведения, а также генерация компилятором
кода для преобразования типа выполняется на **этапе компиляции**.
Нельзя использовать `static_cast` в случае использования
виртуальных методов хотя бы в одном из базовых классов.

* `dynamic_cast<Class*>(pointer)` - выполняет приведение типа
указателя `pointer` к указателю на `Class`. Обычно используется
для приведения типа от базового класса к наследуемому.
Проверка возможности приведения типа выполняется
**во время выполнения**. Если это невозможно, то возвращает нулевой
указатель. В отличии от `static_cast`, правильно заполняет
таблицу виртуальных методов (которая известна только во время
выполнения).

* `dynamic_cast<Class&>(reference)` - выполняет приведение
типа переменной `reference` к ссылке на `Class`. В отличии от
приведения указателя, если приведение невозможно, то
генерируется исключение `std::bad_cast`.

* `reinterpret_cast<T*>(pointer)` - не выполняет никаких
преобразований, и просто возвращает численное значение адреса
указателя как значение типа `T*`.

* `reinterpret_cast<intptr_t|uintptr_t>(pointer)` - возвращает
численное значение адреса как intptr_t или uintptr_t.

* `reinterpret_cast<T*>(int_value)` - возвращает указатель
на значение типа `T`, который указывает на явно переданный
адрес в памяти `int_value`. **Пользоваться осторожно!**.

* `const_cast<T*>(pointer_to_const)` - убирает модификатор
`const` у указателя `pointer_to_const` и возвращает новый
`mutable` указатель. Значения по адресу после этого можно
модифицировать. **Не рекомендуется использовать**.
Использование `const_cast` в коде - это явный признак
неправильно спроектированной архитектуры программы.


Различные сторонние библиотеки могут определять
дополнительные операторы приведения типов, например
`qobject_cast` и `qvariant_cast` в Qt или
`lexical_cast` в Boost.


Представление строк в Си
========================

Строки в Си (не путать с Си++) очень часто представляются
в формате простого массива `char*`, последнее значение
которого равно `'\0'`.

Такие строки размещаются в памяти как непрерывный массив
байт. Символ с кодом `0` может встречаться в середине этого
массива. В таком случае функции, которые предназначены
**для работы со строками** будут считать этот символ концом
строки, несмотря на то, что размер массива может быть больше,
и данные после `'\0'` легко доступны.

Указатель на символ (`char *`) определяет адрес первого
символа в строке. Все остальные символы могут быть получены
инкрементом (эквивалентно - оператором `[]`) этого указателя
на заданное смещение.


```c++
static const char * Hello = "Hello, World!";

char first  = *Hello;        // first  = 'H'
char second = *(Hello + 1);  // second = 'e'
char third  = Hello[2];      // third  = 'l'
char last   = Hello[12];     // last   = '!'
char nullval= Hello[13];     // nullval = 0;

```

Ввиду непрерывности размещения строки в памяти, инкремент
указателя на единицу приводит к тому, что он становится
указателем на следующий символ.


```c++
static const char * Hello = "Hello";

for ( const char * substring = Hello;
      '\0' != *substring;
      ++substring )
{
   printf("%s\n", substring);
}

/* Вывод на экран:
Hello
ello
llo
lo
o
*/

```

В данном примере исходная строка не изменяется, а на экран
выводятся ее подстроки, получаемые сдвигом указателя на один
символ вперед. Обратите внимание, что переменная цикла
объявлена как `const char*`. В данном случае модификатор
`const` относится не к переменной `substring`, значение
которой изменяется, а к типу данных `char*`, то есть нельзя
изменять содержимое, на которое ссылается указатель.

Если требуется объявить неизменяемость самого указателя,
необходимо писать `const` после символа `*`.


```c++
const char * immutable_string    = "You can't modify me!";
char * const immutable_pointer   = "Value can be changed, but pointer not";
const char * const immutable_all = "Everything protected from changes";
```


Копирование строк или последовательности байт
=============================================

Си-строки, в отличии от строк `std::string` присваиваются по
указателю, а не по значению (поскольку строка - это всего
лишь указатель на некоторую область в памяти).

```c++
std::string source("I'm C++ string");
std::string acopy = source;
acopy[2] = 'd';
// acopy = "I'd C++ string", source = "I'm C++ string"

char * cstring = "I'm raw string";
char * reference = cstring;
reference[2] = 'd';
// reference = "I'd raw string", cstring = "I'd raw string"

```

Для копирования данных необходимо использовать одну из
функций, объявленный в `<cstring>` (или `<string.h>` в Си).

* `void *memcpy(void *dest, const void *source, size_t n_bytes)` -
копирует **ровно `n_bytes`** байт из `source` в `dest`.
Естественно, память для `dest` должна быть заранее выделена.
Эту функцию совершенно не волнует содержимое: если где-то
внутри массива встретится символ '\0', то он просто будет
скопирован как обычный символ. Возвращает значение указателя
`dest`.

* `char *strcpy(char *dest, const char *source)` -
копирует из `source` в `dest` столько символов, сколько
встретится до символа '\0' (включая сам этот символ).
Возвращает значение указателя `dest`.

* `char *strncpy(char *dest, const char *source, size_t n_bytes)` -
копирует из `source` в `dest` столько символов, сколько
встретится до символа '\0' (включая сам этот символ),
но **не более чем `n_bytes`**.
Возвращает значение указателя `dest`.

**Замечание.** Функции `strcpy` и `strncpy` требуют, чтобы
память для `dest` была заранее выделена для хранения
необходимого количества символов, причем в достаточном
количестве. Поэтому **никогда не используйте `strcpy`**,
вместо нее нужно использовать функцию `strncpy`, передавая
в качестве третьего параметра размер выделенной под
`dest` памяти.


Определение длины строк
=======================

**Контрольный вопрос.** Какое число выведет приведенная
ниже программа?

```c++
#include <iostream>

int main()
{
    static const char * Hello = "Hello!";
    std::cout << sizeof(Hello) << std::endl;
    return 0;
}
```

<!-- Правильный ответ: 4 или 8 -->

Длина Си-строк определяется с помощью функции `strlen`
за **линейное время**, поэтому желательно избегать её
лишних вызовов.

```c++
#include <cstring>
#include <iostream>

int main()
{
    static const char * Hello = "Hello!";
    const size_t hello_length = strlen(Hello);
    std::cout << hello_length << std::endl;
    return 0;
}

```


Инициализация выделенной памяти
===============================

В заголовочном файле `<cstring>` объявлена одна очень
полезная функция:

`void *memset(void *s, int c, size_t n)` - заполняет
массив из `n` байт, который находится по адресу `s`
**однобайтными** значениями `c` (от `0` до `0xFF`). Возвращает
указатель `s`.

Тип параметра `int c` сохраняется по историческим причинам,
на самом деле переданное значение преобразуется к
`unsigned char`.

Эту функцию можно (и нужно) вызывать после выделения памяти
для массива или буфера, иначе с большой вероятностью,
выделенная память будет содержать какие-то случайные значения.

В приведенном ниже примере, в первых двух способах выделения
памяти под массив целых чисел получаются неинициализированные
переменные, которые можно инициализировать с помощью `memset`.

```c++
#include <iostream>
#include <cstring>

// Просто обертка над int, с конструктором,
// который присваивает начальное значение 123
struct Int {
    int value;
    inline explicit Int() { value = 123; }
};

int main()
{
    // Поскольку программа только что запущена,
    // то немного намусорим в адресном пространстве
    // (для чистоты эксперимента)
    void * garbage = malloc(100*sizeof(int));
    memset(garbage, 0xFF, 100*sizeof(int));

    // Освободим память. На самом деле,
    // заполненные значения 0xFF никуда не потеряются,
    // поскольку выделенные 400 байт - это сильно меньше
    // размера страницы памяти. Функция free только отметит,
    // что память по адресу, указанном в garbage можно
    // использовать повторно
    free(garbage);

    std::cout << "Malloc-allocated: ";
    int * arr = (int*)malloc(4 * sizeof(Int));

    for (int i=0; i<4; ++i) {
        // Будет выведено -1 -1 -1 -1
        // (-1 - это 0xFF)
        std::cout << arr[i] << ' ';
    }

    std::cout << std::endl;

    std::cout << "New-allocated: ";
    int * new_int_arr = new int[4];

    for (int i=0; i<4; ++i) {
        // Будет также выведено -1 -1 -1 -1
        // int - это скалярная величина,
        // у которой нет конструктора
        std::cout << new_int_arr[i] << ' ';
    }
    std::cout << std::endl;

    std::cout << "New-allocated classes: ";
    Int * new_struct_arr = new Int[4];
    for (int i=0; i<4; ++i) {
        // Будет выведено 123 123 123 123
        // Поскольку Int - это класс (~структура),
        // оператор new[] вызывает конструктор
        std::cout << new_struct_arr[i].value << ' ';
    }
    std::cout << std::endl;
    return 0;
}
```


Сравнение строк
===============

**Контрольный вопрос.** Что выведут на экран: а) первая
программа; б) вторая программа, если её вызвать с
аргументом Hello! ?

```c++
#include <iostream>

int main()
{
    static const char * Hello1 = "Hello!";
    static const char * Hello2 = "Hello!";
    std::cout << (Hello1 == Hello2) << std::endl;
    return 0;
}
```
<!-- Правильный ответ: в случае gcc - 1, поскольку
Hello1 и Hello2 - это один и тот же указатель из-за
оптимизации размера кода -->

```c++
#include <iostream>

int main(int argc, char* argv[])
{
    static const char * Hello = "Hello!";
    std::cout << (Hello == argv[1]) << std::endl;
    return 0;
}
```

<!-- Правильный ответ: 0, т.к. это разные указатели -->

Для сравнения строк используется функция `strcmp`:

`int strcmp(const char *s1, const char *s2)` - возвращает
`-1`, `0` или `1`, если `s1<s2`, `s1==s2` или `s1>s2`.

Сравнение строк осуществляется **лексиграфически**, то есть
слева направо сравниваются коды символов до тех пор, пока
у одной из строк не втретится символ `'\0'`, либо встетятся
разные коды символов. Меньшей считается та строка, у которой
код первого отличающегося символа меньше, чем у другой.

Аналогичная функция для сравнения последовательности байт
(то есть, символ `'\0'` не является ограничителем) называется
`memcmp`.


Классы символов
===============

В заголовочном файле `<ctype.h>` определены функции для определения
класса символа:

* `isdigit` - символ является цифрой

* `isalpha` - символ является буквой

* `isalnum` - буква или цифра

* `isblank` - символ отсутствует в текущей кодировке

* `isgraph` - символ псевдографики

* `ispunct` - символ пунктуации

* `isspace` - пробельный символ

* `iscntrl` - управляющий символ (нет графического представления)

* `isprint` - печатный символ (противоположность `iscntrl`)

* `isupper` - символ в верхнем регистре

* `islower` - символ в нижнем регистре


Все эти функции правильно работают с кодировкой ASCII.

Поведение некоторый функций (например, `isupper`/`islower`)
напрямую зависит от используемой **локали**.
